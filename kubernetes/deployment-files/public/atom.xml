<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Farmer</title>
  <icon>https://blog.farmer233.top/favicon.png</icon>
  <subtitle>-Farmer的自习室</subtitle>
  <link href="https://blog.farmer233.top/atom.xml" rel="self"/>
  
  <link href="https://blog.farmer233.top/"/>
  <updated>2022-03-16T04:40:13.288Z</updated>
  <id>https://blog.farmer233.top/</id>
  
  <author>
    <name>-Farmer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生，活</title>
    <link href="https://blog.farmer233.top/2022/03/15/%E7%94%9F%EF%BC%8C%E6%B4%BB/"/>
    <id>https://blog.farmer233.top/2022/03/15/%E7%94%9F%EF%BC%8C%E6%B4%BB/</id>
    <published>2022-03-15T08:27:37.000Z</published>
    <updated>2022-03-16T04:40:13.288Z</updated>
    
    <content type="html"><![CDATA[<p>晃眼间大半年的休闲时光过去了，平淡而消沉地惶惶不可终日。混吃等死四年多，有可能即将面对人生的又一次十字路口，思量再三，发现终归是凡夫俗子一介草民，个人的选择终究会湮没在历史的进程中，索性随波逐流，逃离现场，美其名曰无欲无求，人各有志。</p><p>越来越多的故人失去联系，仅能从偶尔的一条朋友圈窥得一丝身影，惊然发现竟恍如隔世，不知不觉间发现自己正一步步的走向荒原、孤冢。愈发感觉到天机命途，不由我定，唯一能做的就是活着，好好的活着而已。</p><p>生活生活，先生后活。如此生活，别人与我，自有期望。</p><h2 id="不要败给生活"><a href="#不要败给生活" class="headerlink" title="不要败给生活"></a>不要败给生活</h2><p>我相信，慢慢我什么都会有的。</p><p>我会有很多懂我又不懂我的朋友，我会有很多不同姓的家人，我会见到很多风景，也会明白冷暖自知的人间苦楚。我有我的快乐、烦恼，我一步一步地走。</p><p>许久之后，我再回望我的青春时光，那样地生活过。他的身影印在这个城市里，我看见了他那时的理想和热血再一刻不停地催促着他向前走去。</p><h2 id="朝悟道，夕死可矣"><a href="#朝悟道，夕死可矣" class="headerlink" title="朝悟道，夕死可矣"></a>朝悟道，夕死可矣</h2><p>少年心气，已经深刻地认识到了我们自身的平庸，却依然在等待着生活中的诸多无意义。我在路上，不知是在企图逃离现实所赋予我的诸多责任，还是尝试寻找自己所信奉的东西。</p><p>我们这一代人，如此开放却又狭隘，精神如此丰富又贫瘠，如此乐观又封闭，如此喧嚣却又静寂。我们这群寂寞的人类都在忙着说话、交流、呐喊，然后在现实到来的那一刹那成长。我们眼界开阔，却又因为各种价值观，社会压力中被压得踹不过气来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;晃眼间大半年的休闲时光过去了，平淡而消沉地惶惶不可终日。混吃等死四年多，有可能即将面对人生的又一次十字路口，思量再三，发现终归是凡夫俗子一介草民，个人的选择终究会湮没在历史的进程中，索性随波逐流，逃离现场，美其名曰无欲无求，人各有志。&lt;/p&gt;
&lt;p&gt;越来越多的故人失去联系，</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    <category term="emotion" scheme="https://blog.farmer233.top/tags/emotion/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用APIFlask做毕业设计后端—基本简介与Hello APIFlask!(一)</title>
    <link href="https://blog.farmer233.top/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/"/>
    <id>https://blog.farmer233.top/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/</id>
    <published>2022-03-09T11:52:49.000Z</published>
    <updated>2022-03-22T03:53:26.571Z</updated>
    
    <content type="html"><![CDATA[<!-- **『注：本文更新于2022年3月15日』** --><blockquote><p>前言: 由于本人是根据<a href="https://helloflask.com/book/1/" target="_blank" rel="noopener">《Flask Web 开发实战 》</a>一书进行总结、扩展、引申。因此可能存在重复内容，但已取得本书作者许可😀<br>另外本文提及的APIFlask框架也是本书的作者写的, 十分建议购买阅读<br>本文项目对应地存储库: <a href="https://github.com/Farmer-chong/HelloAPIFlask" target="_blank" rel="noopener">https://github.com/Farmer-chong/HelloAPIFlask</a></p></blockquote><p>最近正值毕业阶段，相信许多人的毕业设计都无不例外的选择了Web相关的内容，毕竟这个比较容易实现。我发现许多人都出于从众心理无不例外的使用了Spring全家桶，Spring有着很庞大的生态、久远的历史以及很丰富的社区资料，这使得它被许多从业者使用。但也正是这些优势导致它对新手或者快速上手开发变得十分不好，再加之国内的毒瘤技术社区等原因，使得一个小问题往往需要花费大量的时间来排除错误的答案。</p><p>相比于繁重、学习成本较高的Spring，Flask其简单的语法可以是我们快速的上手完成(应对)毕设这一类学业任务, 因此本文仅停留在 <strong>能用</strong> 阶段, 更多底层原理需要读者自行了解(这里推荐一下李大的狗书<a href="https://helloflask.com/book/1/" target="_blank" rel="noopener">《Flask Web 开发实战 》</a>) 另外出于为社区做贡献等情怀原因也是写这一系列的初衷。</p><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ol><li><a href="./">后端系列: 基本简介与Hello APIFlask! (一)</a><!-- 2.  --></li></ol><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>本文默认使用Windows进行开发，Linux/macOS会特别说明</p></blockquote><blockquote><p>相比于传统的后端渲染模板架构，本文采用目前主流的前后端分离结构</p></blockquote><p>对于前后端分离，服务端只需要提供API接口来处理请求。简单的来说就是前端不再局限于浏览器，还可以是app、小程序亦或者是爬虫程序。对后端而言，我们不再渲染html返回给前端，而是与前端共同约定一个数据格式进行交互。</p><p>如果读者的思想还停留在具体的浏览器中，那需要读者打开思维的局限来理解。无论是传统的后端渲染还是前后端分离，其本质都是操作 <strong>HTTP报文</strong> 。</p><blockquote><p>许多人此时会有个疑问：为什么一会儿Flask一会APIFlask的，这两者有什么关系？</p></blockquote><p>先来简单的说一下，<code>Flask</code>是一个十分流行的 <strong>Python Web</strong> 框架。而<code>APIFlask</code>则是基于<code>Flask</code>框架针对 <strong>Web API</strong>开发的特点二次开发的框架，这是一个针对API而生的框架(或者具体点前后端分离)。如果读者有<code>Java</code>开发经验，可以理解类似于<code>Spring</code>与<code>Spring Boot</code>的关系。</p><p>扩展阅读: </p><ol><li><a href="https://greyli.com/hello-apiflask/" target="_blank" rel="noopener">APIFlask是什么</a></li><li><a href="https://greyli.com/flask-fastapi/" target="_blank" rel="noopener">Flask、APIFlask与其他Web框架之间的关系</a></li></ol><p><em>因为APIFlask是一个Flask的扩展补充框架，因此它大部分都是与Flask保持一致的，你甚至可以把APIFlask当成Flask来写(当然这并不推荐)。因此对Flask有经验的读者许多内容是可以跳过阅读的，我甚至更推荐你去阅读 <a href="https://apiflask.com/" target="_blank" rel="noopener">APIFlask的官方文档</a>。</em></p><h2 id="初识APIFlask-Hello-APIFlask"><a href="#初识APIFlask-Hello-APIFlask" class="headerlink" title="初识APIFlask(Hello APIFlask)"></a>初识APIFlask(Hello APIFlask)</h2><p>废话放在后面说，作为快速上手教程，理所应当地先来个Hello World感受一下<code>Flask</code>的魅力，作为一篇保姆级教程下面就让从<code>pip</code>这个包管理器开始安装一下<code>APIFlask</code>吧（默认安装好python及其包管理器）</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>小白的话就直接运行下面这条命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install apiflask # Linux环境用pip3</span><br></pre></td></tr></table></figure><p>当然本人还是强烈建议使用虚拟环境哈。细节就不多赘述了，下面开始写一个Hello World吧:</p><figure class="highlight python"><figcaption><span>hello/app.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apiflask <span class="keyword">import</span> APIFlask</span><br><span class="line">app = APIFlask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello apiflask!'</span></span><br></pre></td></tr></table></figure><p>哪怕你没有开发经验，单纯的看单词也许已经猜到它是做什么了，下面就来一步步的分解这个程序。</p><h3 id="创建应用实例-application-对象"><a href="#创建应用实例-application-对象" class="headerlink" title="创建应用实例(application 对象)"></a>创建应用实例(application 对象)</h3><p>我们使用<code>pip</code>安装<strong>apiflask</strong>，其实也就是下载了一个叫<strong>apiflask</strong>的包。因此我们可以通过<strong>apiflask</strong>包的构造文件导入开发的类和函数。我们一开始从<strong>apiflask</strong>包导入<strong>APIFlask</strong>类，实例化这个类，就得到了我们的程序实例<code>app</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apiflask <span class="keyword">import</span> APIFlask</span><br><span class="line">app = APIFlask(__name__)</span><br></pre></td></tr></table></figure><p>传入<strong>apiflask</strong>的第一个参数是模块或者包名词，这里使用Python的特殊变量<code>__name__</code>。</p><h3 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h3><blockquote><p>首先对于很多初学者来说都会有这么一个问题：<strong>路由是什么？</strong></p></blockquote><p>回答这个问题之前我们先来看看一个传统的Web应用，客户端和服务器上的程序是如何交互的:</p><ol><li>用户在浏览器输入URL访问某个资源</li><li>APIFlask接收用户请求并分析请求的URL</li><li>APIFlask为这个URL找到对应的处理函数</li><li>执行函数并生成响应，然后返回给浏览器</li><li>浏览器接收并解析响应</li></ol><p>而我们现在要做前后端分离，整个流程和上面是一致的，但客户端具体的对象则从浏览器变成了一段发起 http 请求的代码，以网页前后端分离为例稍微完善一下如下:</p><ol><li>前端使用AJAX向后端发起请求</li><li>APIFlask接收请求并分析请求的URL</li><li>APIFlask为这个URL找到对应的处理函数</li><li>执行函数并生成 HTTP 响应</li><li>AJAX接收响应</li><li>根据后续的业务代码进行页面的修改</li></ol><blockquote><p><em>⚠⚠注意⚠⚠</em> 这里的 <strong>AJAX</strong> 是指 <strong>Asynchronous JavaScript + XML（异步JavaScript和XML）</strong> 这是一个技术名词，读者需要注意与较多人熟知的<code>jQuery</code>库的<code>ajax</code>方法进行区分！！！<br>简单的来讲，<code>jQuery</code>的<code>ajax</code>是 <strong>AJAX</strong> 技术的一个实现，有着许多同类的替代品，比如<code>axios</code>。由于笔者见过太多的人将两者混淆，故在此着重强调。</p></blockquote><p>这些步骤中，大部分都是由APIFlask完成，我们只需要将<strong>处理函数与URL对应起来</strong>。只需在函数添加<code>app.route()</code>装饰器，并传入URL规则作为参数，就可以让URL与函数建立关系。这个过程我们称为注册路由(route)，路由复制管理URL和函数之间的映射，而这个函数则被称为视图函数(view function)。</p><h4 id="1-绑定多个URL"><a href="#1-绑定多个URL" class="headerlink" title="1. 绑定多个URL"></a>1. 绑定多个URL</h4><p>一个视图函数可以绑定多个URL，具体就像下面这段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello apiflask!'</span></span><br></pre></td></tr></table></figure><h4 id="2-动态URL"><a href="#2-动态URL" class="headerlink" title="2. 动态URL"></a>2. 动态URL</h4><p>我们还可以在URL规则中添加变量部分, 使用<code>&lt;变量名&gt;</code>的形式表示。APIFlask处理请求时会把变量传入视图函数，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name:str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Hello <span class="subst">&#123;name&#125;</span>!'</span></span><br></pre></td></tr></table></figure><p>如果URL变量中包含变量，但如果又要适配没有变量的情况，比如与多个URL配合起来使用，那么我们可以给一个默认值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello', defaults=&#123;'name': 'farmer'&#125;)</span></span><br><span class="line"><span class="meta">@app.route('/hello/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name:str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Hello <span class="subst">&#123;name&#125;</span>!'</span></span><br></pre></td></tr></table></figure><h3 id="启动开发服务器"><a href="#启动开发服务器" class="headerlink" title="启动开发服务器"></a>启动开发服务器</h3><p>Flask内置了一个开发服务器(由依赖包Werkzeug)提供，足够在开发和测试阶段使用，而APIFlask是基于Flask二次开发的，因此我们一样可以使用。</p><blockquote><p>在生产环境需要使用性能够好的生产服务器，以提升安全和性能，具体更多内容移步到<a href="https://helloflask.com/book/1/" target="_blank" rel="noopener">《Flask Web 开发实战 》</a></p></blockquote><p>在项目的<strong>根目录</strong>下，输入下面这条命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run</span><br></pre></td></tr></table></figure><p>然后我们会看到如下输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Tip: There are .env or .flaskenv files present. Do "pip install python-dotenv" to use them.</span><br><span class="line">* Environment: production</span><br><span class="line">  WARNING: This is a development server. Do not use it in a production deployment.</span><br><span class="line">  Use a production WSGI server instead.</span><br><span class="line">* Debug mode: off</span><br><span class="line">* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>这时候我们在浏览器访问这个URL，会看到这样显示:</p><img src="/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/index.png" class="" title="hello_apiflask"><p>同理，其他URL自行替换即可得到相应的结果。但由于我们开发的是前后端分离架构，后端只负责提供API进行访问，除了基本的<code>GET</code>请求外还有大量其他请求报文。因为浏览器的调试无疑是不够的，为此<code>APIFlask</code>提供了交互式API文档(基于<strong>Swagger UI</strong> and <strong>Redoc</strong>)</p><p>要进入这个交互式API文档，默认的方式是访问<code>/docs</code>路由，为此我们重新在浏览器访问: <a href="http://127.0.0.1:5000/docs，即可看到下面的这个页面" target="_blank" rel="noopener">http://127.0.0.1:5000/docs，即可看到下面的这个页面</a>:</p><img src="/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/swagger.png" class="" title="api_docs"><p>后续都会基于该API文档进行演示，当然你也可以访问: <a href="http://127.0.0.1:5000/redoc" target="_blank" rel="noopener">http://127.0.0.1:5000/redoc</a> 查看基于Redoc生成的API文档。</p><blockquote><p>需要注意，网上许多教程都是通过<code>app.run()</code>形式来运行开发服务器的，这种方式其实是旧的启动方式，已经过时了目前已不推荐使用(deprecated)。</p></blockquote><p>Flask通过依赖包Click内置了一个CLI(Command Line Interface, 命令行交互界面)系统。当我们安装Flask后，会自动添加一个flask命令脚本，我们可以通过flask命令执行内置命令、扩展插件的命令与我们自定义的命令。其中，<code>flask run</code>命令用来启动开发服务器。</p><p>此外，你还可以执行<code>flask --help</code>查看所有命令，这些命令都需要在项目的根目录执行。</p><h3 id="自动发现程序实例"><a href="#自动发现程序实例" class="headerlink" title="自动发现程序实例"></a>自动发现程序实例</h3><p>上面启动开发服务器我们使用了<code>flask run</code>来启动，这就不禁让人好奇，<strong>Flask</strong>是如何找到程序的？</p><p>其实这个问题是因为<strong>Flask</strong>会自动探测程序实例，一般来说，在执行<code>flask run</code>命令运行程序前，我们需要提供程序实例所在模块的位置，而自动探测是按照下面这些规则:</p><ol><li>从当前目录寻找<code>app.py</code>和<code>wsgi.py</code>模块，并从中寻找名为<code>app</code>或<code>application</code>的程序实例</li><li>从环境变量<strong>FLASK_APP</strong>对应的模块名/导入路径寻找名为<code>app</code>或<code>application</code>的程序实例</li></ol><p>因为我们上面的程序代码文件名为<code>app.py</code>，所以<code>flask run</code>命令会自动在其中寻找应用实例。如果你的程序文件名是其他名称，比如<code>hello_apiflask.py</code>，那么需要设置环境变量<strong>FLASK_APP</strong>，将包含程序实例的模块名赋值给这个变量。命令如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">FLASK_APP</span>=hello_apiflask</span><br></pre></td></tr></table></figure><p>Linux或macOS系统使用<code>export</code>命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=hello_apiflask</span><br></pre></td></tr></table></figure><h3 id="管理环境变量"><a href="#管理环境变量" class="headerlink" title="管理环境变量"></a>管理环境变量</h3><p><strong>FLASK</strong>的自动发现程序实例机制还有第三条规则: 如果安装了<strong>python-dotenv</strong>，那么在使用<code>flask run</code>或其他命令时会自动使用它从<code>.flaskenv</code>文件和<code>.env</code>文件中加载环境变量。</p><p>安装<strong>python-dotenv</strong>包命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-dotenv # Linux环境用pip3</span><br></pre></td></tr></table></figure><p>除了管理自动发现程序实例外，我们还可以用来管理程序需要的环境变量。我们在项目根目录下分别创建两个文件:<code>.env</code>和<code>.flaskenv</code>，其中<code>.flaskenv</code>用来管理和<strong>Flask</strong>相关的公开环境变量。而<code>.env</code>文件则用来管理包含敏感信息的环境变量。</p><blockquote><p><code>.env</code>包含敏感信息，除非是私有项目，否则绝对不能提交到Git仓库中</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><blockquote><p>为什么写扩展阅读，扩展阅读的作用?</p></blockquote><p>扩展阅读模块主要是对上面的内容进行补充，内容并非必读内容并不会影响程序的运行，更多是补充开发相关各方面的知识内容。</p><h3 id="配置热更新-重载器"><a href="#配置热更新-重载器" class="headerlink" title="配置热更新(重载器)"></a>配置热更新(重载器)</h3><p>开发环境(development environment)和生产环境(production environment)。根据运行环境的不同，<strong>Flask</strong>程序、扩展以及其他程序会改变相应的行为和设置。为了区分运行环境，<strong>Flask</strong>提供了一个<strong>FLASK_ENV</strong>环境变量用来设置环境，默认为<code>production</code>(生产)。在开发时我们可以将其设置为<code>development</code>，这会开启所有支持开发的特性，为了方便管理我们还可以将其写入到<code>.flaskenv</code>文件中:</p><figure class="highlight shell"><figcaption><span>./.flaskenv</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLASK_ENV=development</span><br></pre></td></tr></table></figure><p>现在启动程序，你会看到下面的输出提示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(env) E:\Github\HelloAPIFlask\demos\hello&gt;flask run</span><br><span class="line"> * Environment: development</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger PIN: 500-487-380</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>在开发环境下，调试模式(Debug Mode)将被开启，这时执行<code>flask run</code>启动程序会自动激活<strong>Werkzeug</strong>内置的调试器(debugger)和重载器(reloader)，他们会为开发带来很大的帮助。</p><p><strong>如果你想单独控制调试模式开关，可以通过FLASK_DEBUG环境变量来设置，设为1为开启，设为0则关闭，不过通常不推荐手动设置这个值</strong></p><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><blockquote><p>在 Python 中，虚拟环境(virtual enviroment)就是隔离的 Python 解释器环境。通过创建虚拟环境，你可以拥有一个独立的 Python 解释器环境。这样做的好处是可以为每一个项目创建独立的 Python 解释器环境，因为不同的项目经常会依赖不同版本的库或Python版本。使用虚拟环境可以保持全局 Python 解释器环境的干净，避免包和版本的混乱，并且可以方便地区分和记录每个项目的依赖，以便在新环境下复现依赖环境。</p></blockquote><p>虚拟环境通常使用<strong>Virtualenv</strong>来创建，除此之外还有<strong>Pipenv</strong>、<strong>PDM</strong>等诸多环境管理工具。简单起见，我们使用<strong>Python3</strong>自带的工具来创建虚拟环境，首先确保我们当前工作目录在项目的根目录，然后使用<code>python3 -m venv env</code>命令为当前项目创建虚拟环境:</p><figure class="highlight shell"><figcaption><span>Windows</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv env</span><br></pre></td></tr></table></figure><figure class="highlight shell"><figcaption><span>Linux</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv env</span><br></pre></td></tr></table></figure><p><strong>提示: Windows用户可直接复制，但Linux系统大多存在python2与python3，Linux用户需要注意这点</strong></p><p>这会在当前目录创建一个名为<strong>env</strong>的文件夹(命令最后一个选项为文件夹名)，其中包含隔离的Python解释器环境。</p><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><p>在创建虚拟环境后，我们还需要载入(激活)这个环境，接下来使用<code>.\env\Script\active</code>来激活虚拟环境:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\Github\HelloAPIFlask&gt;.\env\Scripts\activate</span><br><span class="line"></span><br><span class="line">(env) E:\Github\HelloAPIFlask&gt;</span><br></pre></td></tr></table></figure><p>Linux环境使用<code>source</code>命令来激活:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">farmer@farmer-ubuntu:~/HelloAPIFlask$ source ./env/bin/activate</span><br><span class="line"></span><br><span class="line">(env) farmer@farmer-ubuntu:~/HelloAPIFlask$ source ./env/bin/activate</span><br></pre></td></tr></table></figure><p>可以看到虚拟环境激活后命令行前面多了一个虚拟环境的标识，这就表示虚拟环境激活啦！使用<code>pip list</code>我们可以看到该环境是一个全新的环境。</p><h3 id="更多启动项"><a href="#更多启动项" class="headerlink" title="更多启动项"></a>更多启动项</h3><ol><li>使服务器外部可见<br>我们上面启动的Web服务器默认是对外不可见的，我们可以通过<code>--host</code>选项将主机地址改为<code>0.0.0.0</code>使其对外部可见:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run --host=0.0.0.0</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>需要注意这里的外部是指你计算机外部，并不是指公网。一般个人的电脑是没有公网IP(公有地址)，所以此时你的程序只能被局域网内的其他用户通过你电脑的IP(内网)进行访问。</p></blockquote><ol start="2"><li>改变默认端口</li></ol><p><strong>Flask</strong>提供的Web服务器默认监听5000端口，你可以通过<code>--port</code>选项进行更改:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run --port=2333</span><br></pre></td></tr></table></figure><p>此时会监听来自2333端口的请求，对应的程序网址也变成了 <a href="http://127.0.0.1:2333/。" target="_blank" rel="noopener">http://127.0.0.1:2333/。</a></p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><blockquote><p>这一切开始于2010年4月1日，<strong>Armin Ronacher</strong>在网上发布了一篇关于”下一代 Python 微框架”的介绍文章，文章里称这个 Denied 框架不依赖 Python 标准库，只需要复制一份 <code>deny.py</code> 放到你的项目文件夹就可以开始编程。随着一本正经的介绍、名人推荐语、示例代码和演示视频，这个”虚假“的项目让不少人信以为真。5天后 <strong>Flask</strong> 就从这么一个愚人节玩笑诞生了。</p></blockquote><p>同样的，<strong>APIFlask</strong>这个框架开始于 2021年4月1日，不知道是机缘巧合还是<a href="https://greyli.com/" target="_blank" rel="noopener">Grey Li</a>有意为之的一个小玩笑，<strong>APIFlask</strong>与<strong>Flask</strong>均诞生于4月1日这一天。🎉🚀✨</p><p>在与<a href="https://greyli.com/" target="_blank" rel="noopener">Grey Li</a>求证后得知两者选择同一天发布是有意为之的！！😄</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- **『注：本文更新于2022年3月15日』** --&gt;


&lt;blockquote&gt;
&lt;p&gt;前言: 由于本人是根据&lt;a href=&quot;https://helloflask.com/book/1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Flask</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="Flask/APIFlask" scheme="https://blog.farmer233.top/tags/Flask-APIFlask/"/>
    
  </entry>
  
  <entry>
    <title>用Rust为Python加双翅膀</title>
    <link href="https://blog.farmer233.top/2022/01/15/%E7%94%A8Rust%E4%B8%BAPython%E5%8A%A0%E5%8F%8C%E7%BF%85%E8%86%80/"/>
    <id>https://blog.farmer233.top/2022/01/15/%E7%94%A8Rust%E4%B8%BAPython%E5%8A%A0%E5%8F%8C%E7%BF%85%E8%86%80/</id>
    <published>2022-01-15T14:22:42.000Z</published>
    <updated>2022-01-15T17:59:31.244Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习<code>Rust</code>，这是一门系统级语言。保证安全的同时摆脱了<code>GC</code>, 它很香同时也很难上手, 刚学完一点皮毛知识决定做个小玩意儿玩玩，是骡子是马总要拉出来溜溜~</p><p>目前个人认为<code>Rust</code>在性能上是可以和<code>C++</code>媲美的一门语言，既然如此那就用它来为<code>Python</code>加个速吧！😊</p><h2 id="起步准备"><a href="#起步准备" class="headerlink" title="起步准备"></a>起步准备</h2><p>为<code>Python</code>加速与写<code>C语言</code>扩展类似，最终通过<code>pyd</code>来调用。在此之前我们用到<code>Rust</code>的<code>pyo3</code>库，另外我们编写的是一个<code>lib</code>而不是应用程序，因此我们要创建<code>lib</code>项目。</p><p>创建<code>lib</code>库项目: </p><p><code>$ cargo new &lt;project name&gt; --lib</code></p><p>在 <strong>Cargo.toml</strong> 文件添加<code>pyo3</code>依赖: </p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"string_sum"</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">"cdylib"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies.pyo3]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.15.1"</span></span><br><span class="line"><span class="attr">features</span> = [<span class="string">"extension-module"</span>]</span><br></pre></td></tr></table></figure><h2 id="一个小Demo"><a href="#一个小Demo" class="headerlink" title="一个小Demo"></a>一个小Demo</h2><p>使用文档的例子，编写一个<code>Hello World</code>试试，代码如下: </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> pyo3::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Formats the sum of two numbers as string.</span></span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum_as_string</span></span>(a: <span class="built_in">usize</span>, b: <span class="built_in">usize</span>) -&gt; PyResult&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>((a + b).to_string())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A Python module implemented in Rust.</span></span><br><span class="line"><span class="meta">#[pymodule]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string_sum</span></span>(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; &#123;</span><br><span class="line">    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;</span><br><span class="line">    m.add_function(wrap_pyfunction!(test_func, m)?)?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用打包命令将这个项目build一下:<br><code>$ cargo build --release</code></p><p>这时候应该能看到项目的结构如下: </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├─src</span><br><span class="line">└─target</span><br><span class="line">    ├─release</span><br><span class="line">    │  ├─.fingerprint</span><br><span class="line">    │  ├─build</span><br><span class="line">    │  ├─deps</span><br><span class="line">    │  ├─examples</span><br><span class="line">    <span class="string">|  ├─string_sum.dll</span></span><br><span class="line">    <span class="string">|  ├─string_sum.d</span></span><br><span class="line">    <span class="string">|  ├─libstring_sum.dll.a</span></span><br><span class="line">    │  └─incremental</span><br><span class="line">    └─rls</span><br></pre></td></tr></table></figure><p>这里的<strong>string_sum.dll</strong>就是我们需要的，我们将文件的扩展名改成<code>pyd</code>即可得到我们的<code>python</code>扩展文件 -&gt; <code>string_sum.pyd</code></p><p>完成之后尝试一下调用这个文件，新建一个<code>test</code>文件夹并将其复制进去, 最后调用一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string_sum</span><br><span class="line">print(string_sum.sum_as_string(<span class="number">200</span>, <span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># export: 233</span></span><br></pre></td></tr></table></figure><h2 id="CPU运算性能Demo"><a href="#CPU运算性能Demo" class="headerlink" title="CPU运算性能Demo"></a>CPU运算性能Demo</h2><p>继续在刚刚的文件中添加一个需要大量计算的函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_func</span></span>() -&gt; PyResult&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> f <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> m(a) + m(b) + m(c) + m(d) + m(e) + m(f)</span><br><span class="line">                                == a * <span class="number">10_0000</span> + b * <span class="number">1_0000</span> + c * <span class="number">1000</span> + d * <span class="number">100</span> + e * <span class="number">10</span> + f</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">println!</span>(<span class="string">"&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;"</span>, a, b, c, d, e, f);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="built_in">String</span>::new());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A Python module implemented in Rust.</span></span><br><span class="line"><span class="meta">#[pymodule]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string_sum</span></span>(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; &#123;</span><br><span class="line">    m.add_function(wrap_pyfunction!(test_func, m)?)?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续的步骤与上面一致，编译重命名后拷贝到<code>python</code>目录下，修改一下刚才的<code>python</code>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string_sum</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * x * x * x * x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                    <span class="keyword">for</span> e <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                        <span class="keyword">for</span> f <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                            <span class="keyword">if</span> m(a) + m(b) + m(c) + m(d) + m(e) + m(f) == a * <span class="number">10</span>_0000 + b * <span class="number">1</span>_0000 + c * <span class="number">1000</span> + d * <span class="number">100</span> + e * <span class="number">10</span> + f:</span><br><span class="line">                                print(<span class="string">f"<span class="subst">&#123;a&#125;</span><span class="subst">&#123;b&#125;</span><span class="subst">&#123;c&#125;</span><span class="subst">&#123;d&#125;</span><span class="subst">&#123;e&#125;</span><span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_fun</span><span class="params">(func, flage:str = <span class="string">"Python"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""计时函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        func (function): 回调函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;flage&#125;</span> time: "</span>,end - start)</span><br><span class="line">    <span class="keyword">return</span> start - end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始计时 -&gt; Rust</span></span><br><span class="line">rust_time = test_fun(string_sum.test_func, flage=<span class="string">"Rust"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试纯Python</span></span><br><span class="line">python_time = test_fun(target_func)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Rate: <span class="subst">&#123;python_time/rust_time&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>运行看一下结果，从结果看到<code>Rust</code>比<code>Python</code>足足快了<strong>125倍</strong>多！！！</p><img src="/2022/01/15/%E7%94%A8Rust%E4%B8%BAPython%E5%8A%A0%E5%8F%8C%E7%BF%85%E8%86%80/rust2python.png" class="" title="result">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习&lt;code&gt;Rust&lt;/code&gt;，这是一门系统级语言。保证安全的同时摆脱了&lt;code&gt;GC&lt;/code&gt;, 它很香同时也很难上手, 刚学完一点皮毛知识决定做个小玩意儿玩玩，是骡子是马总要拉出来溜溜~&lt;/p&gt;
&lt;p&gt;目前个人认为&lt;code&gt;Rust&lt;/code&gt;在</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Rust" scheme="https://blog.farmer233.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>校招杂谈</title>
    <link href="https://blog.farmer233.top/2021/12/08/%E7%A7%8B%E6%8B%9B%E6%9D%82%E8%B0%88/"/>
    <id>https://blog.farmer233.top/2021/12/08/%E7%A7%8B%E6%8B%9B%E6%9D%82%E8%B0%88/</id>
    <published>2021-12-08T12:09:49.000Z</published>
    <updated>2021-12-12T14:42:07.656Z</updated>
    
    <content type="html"><![CDATA[<p>秋招结束后就一直想写一篇总结，但个人比较懒躺平了好久:D。最近老师给我布置了个任务写一下秋招这段时间的面试经验总结, 就不继续鸽了吧😄 继回顾完大学生涯后再来看看近段时间的校招悲剧吧 :(</p><p>如果不读研，校招可以说每个人一生只有一次，当你毕业了也就失去应届生这个身份了也就不能参与校招了。因此校招这个机会是十分重要且难得的，一定要尽早准备参加，重视重视再重视！！！⚠️ </p><p>切记 <strong>春招找实习，秋招拿offer</strong></p><p>虽然应届生身份法规上是两年内，但又有几个公司这么看尼～</p><h2 id="重要的东西写在前头"><a href="#重要的东西写在前头" class="headerlink" title="重要的东西写在前头"></a>重要的东西写在前头</h2><p>首先说一个思想上的几个误区：</p><ol><li>许多人认为没毕业就不能去应聘</li><li>我才大三，校招离我还远</li><li>学校大四还有课，找到了也去不了不如不去面试</li><li>我是前端，后端的那些就不复习了</li></ol><p>据我观察我们学校很多人都有这个误区，但其实并非这样。校招可以说当你踏入大三，就要开始准备了！另外对于面试官来说，应届生只有CS专业与非CS专业的两种情况，你前端还是后端只是决定了考察的重点或者问题方向罢了。下面就来详细的展开说说校招的这些事吧～</p><p>开始之前先介绍一下个人情况吧，看官还请结合自身实际参考阅读：</p><ol><li><code>Python</code>、<code>JavaScript</code>、<code>golang</code>这三门语言为我的主技术栈, 当然别的语言也会点。</li><li>框架方面：<code>Flask</code>、<code>APIflask</code>、<code>gin</code>、<code>Vue</code>等常见的web开发框架我都能熟练的使用</li><li>裸考软考网络工程师</li><li>有一颗热爱计算机、热爱折腾的心</li></ol><p>我秋招拿到还不错的offer有：</p><ol><li>深圳明源云-base深圳</li><li>深圳深信服-base深圳</li><li>北京美团闪送-base北京</li></ol><p>在编程方面，你应该有以下的基本素养：</p><ol><li>会写注释、会写文档</li><li>变量名清晰明了</li><li>函数功能划分清楚、职责单一（❌冗长的函数）</li><li>习惯看官方文档，拒绝看垃圾博客（如csdn）</li><li>接口协议设计合理、规范清晰</li><li>添加功能的时候多一点思考（如扩展性）</li><li>习惯写测试用例、单元测试（正所谓一行代码千行测试）</li><li>代码问题输出使用规范化的log记录</li><li>提交代码要规范</li></ol><h2 id="一个比较常规的应届生校招流程"><a href="#一个比较常规的应届生校招流程" class="headerlink" title="一个比较常规的应届生校招流程"></a>一个比较常规的应届生校招流程</h2><img src="/2021/12/08/%E7%A7%8B%E6%8B%9B%E6%9D%82%E8%B0%88/school-recruit.png" class="" title="recruit"><p>上图可以说是大学生应该知道的招聘流程，我以一个刚步入大三的学生身份来remake整个流程。是的，大三开学就需要开始准备校招事宜了！</p><h3 id="大三开学首先要做这几件事："><a href="#大三开学首先要做这几件事：" class="headerlink" title="大三开学首先要做这几件事："></a>大三开学首先要做这几件事：</h3><ol><li>制作简历</li><li>浏览意向的岗位资讯</li><li>开始复习八股文</li><li>开始刷题、刷算法</li></ol><p>在学期末的时候开始投递简历，应聘大厂的实习岗位。实习可以说是我们三本学生进入大厂为数不多的机会了，切记要把握好！</p><h3 id="大三第二个学期"><a href="#大三第二个学期" class="headerlink" title="大三第二个学期"></a>大三第二个学期</h3><p>常言道：春招找实习、秋招拿offer。这个学期开学一般都是3月份了，这时候你应该已经在寒假就完成简历的投递了。这个学期的主要任务就是：</p><ol><li>找到实习</li><li>继续八股文、算法的复习</li><li>了解提前批动态</li></ol><p>每年的提前批时间都不一样，需要自行上牛客网浏览相关资讯。关注大厂提前批的动态。</p><h3 id="大三与大四中间的暑假"><a href="#大三与大四中间的暑假" class="headerlink" title="大三与大四中间的暑假"></a>大三与大四中间的暑假</h3><p>这个暑假一般而言是在秋招应聘的实习公司与面试中度过的，争取拿到正式offer是这个时间段唯一目标！有实习经历与没有实习经历是有很大差距的！具体原因下文会讲到。</p><h3 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h3><p>大四开学就是9月了，也是正式的校招与秋招的开始。是厮杀的最火热的时间段。    </p><p>在这个时间段往往会遇到<strong>卡简历</strong>、<strong>卡学历</strong>等等的不公平待遇，这也是为什么说提前批争取上岸的原因。<br>这个时间段的笔试，除非你能答到基本满分，否则你可能连面试官都见不到。</p><p>至于笔试题的难度，按ACM标准来看就好了。至于秋招结束还没上岸或者拿不到保底，那只能希望来年的春招了。</p><h2 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h2><p>简历是十分重要的，最重要的是一个“真”字。内容一定要真实会就会，不会就不会。其次是“精”，切忌杂七杂八的东西往上丢，比如项目部分写学校的课程实训就很掉分。</p><p>最后需要注意里面的内容需要突出重点而不是一股脑的全丢上面。尽可能控制在一页内，主要包含你会的技术栈、能拿得出手的项目、经历与技能证书、自我评价这几个部分，下面详细展开来说。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>在技术栈上，经可能的突出与求职岗位所匹配的技术。另外需要注意描述技能掌握程度时的词语<strong>了解</strong>，<strong>熟悉</strong>和<strong>精通</strong>的区别。<br>“了解”指对某项技术只是全面学习过或看过书，但并没有做过实际的项目。一般不建议在简历中写只是肤浅地了解一点的技能，如：只是在我校Java课程中学过java，那就只能算了解。</p><p>在简历描述中的掌握程度大部分应该是“熟悉”，一般毕业生是使用不到“精通”的。“熟悉”意味着你对这门技术有着深入的使用且已经有较长的时间，通过查阅相关文档可以独立解决大部分问题，那么我们就能熟悉它了。</p><p>⚠️需要注意，学习的课程实训并不能算数！举几个例子，熟悉 MySQL 你应该能清楚的知道<strong>事务隔离级别</strong>、<strong>sql调优</strong>、处理过数据库事物并发带来的相关问题等许多细节；熟悉 Python 你应该知道<strong>GIL(全局解释锁s)</strong>、<strong>元编程</strong>、<strong>魔法方法(magic function)</strong>、<strong>迭代器生成器装饰器(iterator, generator, decorator)</strong>等等（如果你刚好也是Python技术栈，那我推荐你看一下《流畅的Python》这本书）；最后再以人数最多Java来举例子，Java你应该知道<strong>JVM内存区域布局</strong>、<strong>基本的垃圾回收机制和原理</strong>、各种集合类的底层原理、各种<code>InputStream/OutputStream</code>的区别，特别是HashMap中的<strong>桶结构的进化与退化</strong>以及接口，抽象类区别，应用场景。</p><p>还有一些计算机通用的底层原理（八股文）就不过多赘述了。</p><h3 id="项目与经历部分"><a href="#项目与经历部分" class="headerlink" title="项目与经历部分"></a>项目与经历部分</h3><p>项目与经历最好就是写你实习负责的项目与实习经历⚠️<strong>切忌将学校课程实训的项目也往上写</strong>⚠️因为这类项目根本无法吸引面试官眼球！甚至让面试官感觉你技术就那样儿～ 因此宁可只有一个也不写多，宁愿刚八股文也不要让面试官对你没兴趣！</p><p>项目这部分是简历中最重要的，因为它直接关系到面试官与你谈的内容。以我这几次面试来看面试官对你的项目问的越多，了解的越深入越感兴趣你就越有戏，我有几次甚至因为和面试官聊项目聊到timeout了😂面试官也对这个项目给出了好多有用有意思的建议！如果项目面试官不感兴趣的话，那就只能问你八股文了，这样除了要有扎实的基本功外还要看你能否答到面试官想听的点了，这难度就可想而知了～ 总的来说你的项目就是要让面试官感兴趣，因此项目部分提炼出来的要点如下：</p><ol><li>最好是实习的项目</li><li>项目比较有趣、新颖、吸引眼球</li><li>切忌把烂大街的项目放到简历上</li></ol><h3 id="技能证书与自我评价"><a href="#技能证书与自我评价" class="headerlink" title="技能证书与自我评价"></a>技能证书与自我评价</h3><p>自我评价想不到说啥，就来说说技能证书吧～ 技能证书其实也是按照精而不多原则来填写（这不是废话），当然真实的情况往往是没有几个能拿得出手的证书😄 这时候就有要按公司、按职位来写了。</p><p>以英语证书为例，如果你投的岗位与公司对英语水平没有太大要求而你又只有四级证书，那最好还是不要填写四级证书为好。因为在整个应届生群体中雅思托福的不在少数，你的简历上的四级反而是一个掉分项！</p><h2 id="面试八股文"><a href="#面试八股文" class="headerlink" title="面试八股文"></a>面试八股文</h2><ol><li>数据结构与算法</li><li>操作系统原理</li><li>计算机网络</li><li>数据库</li></ol><p>在复习上面的内容时，切记不要按学校教的来复习! 因为学校教的不够深入，前三部分建议参考考研408的真题。按考研的难度来复习就对了。八股文与考研这些东西，网上资料十分详细（特别是GitHub上面）这里就不展开细说了，列几个我认为秋招一定要会的基本功吧：（后面想起来会动态补充）</p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>这部分按考研标准来就好了，几种常见排序、数据结构是一定要会的～ 这里推荐《小灰算法》这本书，里面所讲的都是面试的基础。</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol><li>OSI 七层模型分别是？各自的功能是什么？</li><li>一次完整的http请求过程包括那些内容</li><li>http本质上是什么？ get和post的区别有哪些？从底层原理上回答</li><li>http与https的区别？https如何保证数据传输安全</li><li>什么是SSL/TLS？</li><li>一个tcp链接可以对应几个http request？</li><li>浏览器对同一个Host建立tcp链接的数量有没有限制？</li><li>DNS是什么？两种查询方法了解过吗？工作原理是什么？</li><li>http长链接与短链接的区别</li><li>get方法的长度限制是怎么回事？</li><li>Cookie与Session的区别？session的工作原理是什么？不同框架对session的实现有什么不同？</li><li>SQL注入了解吗？ 简单的注入会不会？</li><li>CSRF攻击、CSS攻击是什么？</li><li>TCP包头结构，各字段的功能与作用</li><li>TCP的粘包/拆包问题，发生的原因？</li><li>常见的tcp攻击了解吗？会复现吗？</li><li>tcp的三次握手四次挥手</li><li>tcp四大拥塞控制算法，tcp的滑动窗口</li><li>流量控制原理会吗？tcp如何保证可靠性传输？</li><li>udp是什么？tcp与udp的区别</li><li>服务器出现大量close_wait的原因是什么？怎么解决？</li></ol><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>这一part本人不熟，以 MySQL 与 Redis 为主：</p><ol><li>事务是什么？</li><li>MySQL事务隔离级别</li><li>并发问题？脏读、幻读与不可重复读？</li><li>MySQL对repeat table read做了什么？</li><li>索引原理</li><li>B+树是什么？并且对比红黑树与其他数据结构</li><li>死锁怎么造成的？怎么处理？</li><li>什么是MVCC？</li><li>MyISAM与Innodb</li><li>表结构优化、sql调优</li><li>跳表(SkipList)</li><li>Redis的两种存储是什么？</li><li>服务器宕机后数据怎么恢复</li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>进程、线程与协程的区别</li><li>线程进程到底是什么？</li><li>一个进程可以创建几个线程？</li><li>进程线程模型</li><li>Linux下进程间通信方式</li><li>Linux下同步机制</li><li>内存交换与覆盖的区别</li><li>虚拟技术了解吗？容器技术了解吗？</li><li>进程状态的切换知道多少？</li><li>一个程序从开始到结束整个生命周期的过程</li><li>进程同步的四种方法？</li><li>两个经典问题：哲学家与消费者</li><li>说说几种典型的锁？</li><li>死锁相关</li><li>malloc申请内存时候，操作系统做了什么？</li><li>说说new、malloc、del与free</li><li>说说守护进程与僵尸进程和孤儿进程</li><li>服务器高并发的解决方案有哪几个？</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;秋招结束后就一直想写一篇总结，但个人比较懒躺平了好久:D。最近老师给我布置了个任务写一下秋招这段时间的面试经验总结, 就不继续鸽了吧😄 继回顾完大学生涯后再来看看近段时间的校招悲剧吧 :(&lt;/p&gt;
&lt;p&gt;如果不读研，校招可以说每个人一生只有一次，当你毕业了也就失去应届生这</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Review of life in university ✔</title>
    <link href="https://blog.farmer233.top/2021/11/07/Review-of-life-in-university/"/>
    <id>https://blog.farmer233.top/2021/11/07/Review-of-life-in-university/</id>
    <published>2021-11-06T17:05:52.000Z</published>
    <updated>2021-12-08T12:08:00.695Z</updated>
    
    <content type="html"><![CDATA[<p>最近秋招尾声，对于职场小白的我来说有许许多多不懂、迷茫得地方。<strong>幸运的</strong>是我有着几个愿意听我埋怨，在我面试紧张时听我话痨，在我迷茫时给予我中肯建议的朋友，万分感谢！</p><p>过去的已无法改变，总结一下过去四年发生的点滴无论好坏，也叫作给自己一个交待吧。毕竟我们不也天天code-review么</p><p>不知不觉四年就过去了，最近经历了秋招见识到了找工作的艰辛，也有收获到了offer的喜悦，同时也有着选offer的纠结。找工作的艰辛源于自身实力不足，收获的offer是对我四年努力的肯定，选offer的纠结是出于对自身现状的不满。Anyway, dont stop learning.</p><h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>回顾过去，一个小白从网络入坑计算机到逐步转型web狗🐕再到现在慢慢靠近云原生、微服务相关领域。经历的点点滴滴，让人不禁感叹如果能remake该多好😶。</p><p>如果将大学四年放到整个计算机生涯中，那我会比作从婴儿蹒跚学步到一个学徒入门的水平。还记得刚入学的时候怀揣着一颗敬畏的心去面试部门，希望在这里能找到志同道合的人。现在看来这个决定是十分正确的。还记得大一下学期的时候，忐忑的去面试当时垄断校园公众号的小喵团队。二面时那“艰巨”的任务让许多人望而却步，庆幸的是我没有放弃。</p><ol><li>掌握python语法</li><li>学会使用git进行版本管理、提pr</li><li>学会flask框架，并开发一个简单的应用</li><li>一个星期内完成上述任务</li></ol><p>虽然这一个星期我活得很狼狈，但也正是这一个星期让我正式的踏上了开发这条路。大一如果说是跌跌撞撞的入门，那么大二可以说是渐入佳境、步入了快车道了。</p><p>大二一年可以说是完成了web前后端的一个蜕变。从与同学打闹的一个爬虫小程序到为了偷懒不跑<code>i广科</code>而写的一个定时爬虫小jio本，从<code>flask框架</code>与<code>Jinja2</code>模板的传统web开发到<code>flask</code>与<code>Vue</code>的前后端分离，以及不知何时学会的<code>JavaScript</code>。</p><p>大三是一个比较<em>卷</em>的一段时间，从<strong>手撸http协议</strong>到<strong>手撸玩具分布式</strong>再到前端Vue的一些底层api、原理的学习。也是从大三这个阶段，开始有了考研的想法，虽然这个想法动摇的十分厉害，就像大海上的小舟一样随波漂流。经过思考后我决定两个都要(小孩子才做选择)🤣不过此时的我还纯纯的不知道春招、秋招、提前批这些东西是啥，回过头来看真的挺呆的。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>到了大四了，无论是不是想找工作。在周围人的影响下我了解到了秋招、春招等信息，一开始还不是很上心，毕竟学校还有课程，考研408也还没看多少，八股文就更不用说了比408有过之而无不及。</p><p>大四是一个毕业的季节，同时也是考研的冲刺阶段。无论如何我都应该做出一个抉择了，要么考研要么秋招。对于一个末流三本的菜狗来说无论哪一条路都不好走，对于一个选择困难症晚期患者来说这是十分折磨人的。在一众吃瓜群友的吐苦水后，我选择了秋招这条路，现在看来这个决定还不错。秋招拿到了5份offer，选offer也不是件省心的事儿。因为无论是<strong>北上广深</strong>于我而言都是离家，别人也给不了太多的意见终归还是要自己做决定。从公司的待遇与职位的匹配度到所在城市的风俗习惯再到相关的入户政策等等诸多细枝末节的考虑，真让人头昏脑胀。</p><p>秋招也结束了，就等三方的流程走完就尘埃落定。虽然明年春招或许会再尝试，不过躺平又未尝不是一种选择？</p><h2 id="Remake"><a href="#Remake" class="headerlink" title="Remake"></a>Remake</h2><p>如果让我现在回到大一，我有什么是比较后悔的？我会怎么重新选择学习路线？我又会怎么弥补这些遗憾？</p><p>后悔事值得总结的大概就两件吧。其一是没有好好准备求职，比如没有参与春招实习、秋招导致错过了求职的黄金时间。另一件则是知乎上的热门话题了：<strong>为什么大学生都喜欢翘课</strong>，大一大二的公共课浪费了许许多多的精力与时间。如果给我现在回到大一，我会勇敢的翘了。如果你问我学校的课程有没有用？答案是不太有用。真实的情况往往是学校教学的内容早已掌握甚至比老师还会，这不是狂而是三本无奈的现状。教学的老师往往是开学前的一个星期临时自学然后就参与教学活动中来，上课讲错基础概念更是常有的事，这就是我为什么说<strong>上课浪费了我大量的精力与时间</strong>。第二个原因则是因为我已掌握的知识能反哺课程。以web开发为例，不外乎就是操作<code>http协议</code>与<code>数据库的CRUD</code>。熟悉了这个其实换框架只需几个小时，或者通过代码提示甚至可以直接上手完成实训、考试。往往裸考的成绩都能排到全班前三，真是讽刺啊~</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h2><p>骂骂咧咧的写了篇流水账，过段时间再看回来或许会直接社死了吧。 Anyway, lifelong learning. 学习永远不晚，别停下学习的步伐就好啦。</p><h3 id="关于学校3-1-创新班"><a href="#关于学校3-1-创新班" class="headerlink" title="关于学校3+1(创新班)"></a>关于学校3+1(创新班)</h3><p>很多人都问过我3+1是否能去，废话不多说结论放在前头：</p><ol><li><strong>不要去3+1</strong></li><li><strong>不要去创新班!</strong></li></ol><p>当然事无绝对，觉得合适就好~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近秋招尾声，对于职场小白的我来说有许许多多不懂、迷茫得地方。&lt;strong&gt;幸运的&lt;/strong&gt;是我有着几个愿意听我埋怨，在我面试紧张时听我话痨，在我迷茫时给予我中肯建议的朋友，万分感谢！&lt;/p&gt;
&lt;p&gt;过去的已无法改变，总结一下过去四年发生的点滴无论好坏，也叫作给自</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>A distributed system with Go</title>
    <link href="https://blog.farmer233.top/2021/09/05/A-distributed-with-Go/"/>
    <id>https://blog.farmer233.top/2021/09/05/A-distributed-with-Go/</id>
    <published>2021-09-04T16:21:43.000Z</published>
    <updated>2021-12-22T01:55:47.710Z</updated>
    
    <content type="html"><![CDATA[<p>从上学期开始，学校的教务系统更新了。新版的正方多了一个负载均衡的功能，但无奈实在做的太差了！为什么这么说尼？<br>因为在上学期抢课的时候入口网关依旧拉闸，而真正的后端服务器访问速度比德芙还丝滑。因此暂将锅甩给负载均衡服务器。既然学校的负载均衡拉闸，那么就有了 <strong>“帮学校做负载均衡”</strong> 的想法。<br>大体的思路就是，通过扫描内网网段发现隐藏的地址，然后负载均衡这些隐藏的地址。<br>既然是负载均衡，第一时间想到的就是<code>Nginx</code>了，通过资料搜集，大致确定了基本的流程，因此有了这么的这个流程图:</p><img src="/2021/09/05/A-distributed-with-Go/floatChart.dio.png" class="" title="floatChart"><a id="more"></a><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><p>由于非官方的代理，因此我们无法知道教务系统部署在内网的哪些机器上，而校园网一般使用B类网，因此需要扫描大量的ip地址。<br>但这样无疑会触发学校网管的报警，正常情况下会导致ip短时间内被封。导致扫描质量低（由于被禁网，导致程序误认为扫描超时从而导致目标未被发现）。<br>基于这个问题，随之而生的想法就是分布式扫描，将扫描的工作打散到用户中，服务器只负责扫描几个主干网段。<br>一句话概括就是: <strong>将扫描工作分散到多台机器上</strong>，流程图如下：</p><img src="/2021/09/05/A-distributed-with-Go/microService.dio.png" class="" title="microService"><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><blockquote><p>前情提示: 本文通信均采用HTTP、代码部分存在伪代码<br>代码仓库: (暂不开源)</p></blockquote><ol><li>注册中心 -&gt; <strong>服务注册</strong>与<strong>服务发现</strong></li><li>日志服务 -&gt; 记录日志</li><li>数据库服务 -&gt; 数据库操作(CRUD)</li><li>扫描器服务 -&gt; 发现教务系统地址</li><li>测试器服务 -&gt; 测试数据库中地址的<strong>健康度</strong></li><li>Api服务 -&gt; 向<code>consul</code>发送负载信息</li></ol><p>大致结构如下：</p><img src="/2021/09/05/A-distributed-with-Go/scanner.dio.png" class="" title="scanner"><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>作为一个分布式系统，不可避免地需要<strong>服务注册</strong>与<strong>服务发现</strong>。因此需要一个<code>注册中心</code>来处理各个<code>服务</code>之间的依赖关系，在服务上线后通知依赖这个服务的服务(这里有点绕)<br><strong>举个例子</strong>:<br><code>数据库</code>的每个操作都需要记录日志，日志为了统一管理所以有一个<code>日志服务</code>专门处理日志信息。此时，<code>日志服务</code>因某些原因(可能是人为、也可能是网络掉线等)在<code>数据库服务</code>注册之后才注册，这是<code>注册中心</code>就需要通知<code>数据库</code>，让<code>数据库</code>的日志记录转成使用<code>日志服务</code>。</p><h3 id="功能与实现"><a href="#功能与实现" class="headerlink" title="功能与实现"></a>功能与实现</h3><p>作为一个注册中心，首先我们需要一个web服务来接收服务发送的信息(注册、依赖更新、注销等等)，但在这之前我们先来定义一下我们要用到的结构(在面向对象中为类)</p><ol><li><code>registry</code>来表示注册操作<ul><li><code>registrations</code>来存放注册的服务</li><li><code>add</code> 注册服务</li><li><code>notify</code> 事件通知</li><li><code>sendRequiredServices</code> 发送依赖的服务</li><li><code>sendPatch</code> 发送依赖项</li><li><code>remove</code> 移除(注销)服务</li><li><code>Heartbeat</code> 心跳包</li></ul></li><li><code>Registration</code>表示服务注册结构体<ul><li><code>ServiceName</code> 服务名</li><li><code>ServiceURL</code> 服务地址</li><li><code>RequiredServices</code>[数组]服务依赖项</li><li><code>ServiceUpdateURL</code> 服务与注册中心沟通的URL</li><li><code>HeartbeatURL</code> 心跳检测地址</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务注册结构体</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">RequiredServices []ServiceName</span><br><span class="line">ServiceUpdateURL <span class="keyword">string</span></span><br><span class="line">HeartbeatURL     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 添加注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当依赖服务运行时，通知依赖者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">notify</span><span class="params">(fullpatch patch)</span></span> </span><br><span class="line"><span class="comment">// 注册中心向服务发送依赖相关内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendRequiredServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 发送依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 移除注册（注销）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 心跳包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span> <span class="title">Heartbeat</span><span class="params">(freq time.Duration)</span></span></span><br></pre></td></tr></table></figure><p>既然注册中心是作为一个web服务实现的，那么肯定是需要一个<code>web server</code>的，由于项目属于玩票性质，也不算大因此使用Go内置的<code>net/http</code>来实现，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Request received"</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line">decoder := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := decoder.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"Adding service: %v with URL: %s\n"</span>, r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"Removing service at URL: %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务组件"><a href="#服务组件" class="headerlink" title="服务组件"></a>服务组件</h2><p>对服务来说，就是根据注册中心定好的规则来注册服务，然后根据自身的依赖来处理对应的功能。<br>因为要处理相应的依赖，因此除了<code>Registration</code>外，再定义一个处理服务依赖的结构体及方法: <code>providers</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span>   <span class="comment">// 服务名-&gt;服务url</span></span><br><span class="line">mutex    *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新依赖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *providers)</span> <span class="title">Update</span><span class="params">(pat patch)</span></span></span><br><span class="line"><span class="comment">// // 通过服务名称，找到依赖的urls，从依赖项里面随机返回一个url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p providers)</span> <span class="title">get</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="comment">// 导出给外部使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProvide</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure><h3 id="组件的web服务"><a href="#组件的web服务" class="headerlink" title="组件的web服务"></a>组件的web服务</h3><p>因为每个服务都需要使用<strong>注册</strong>这些通用的功能，且这部分的工作都是重复的，因此将web抽出来公用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">RegisterHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">RegisterHandlersFunc()</span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, ServiceName registry.ServiceName,</span></span></span><br><span class="line"><span class="function"><span class="params">host, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line">srv.Addr = <span class="string">":"</span> + port</span><br><span class="line">address := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(srv.ListenAndServe())</span><br><span class="line"><span class="comment">// 关闭的时候要取消注册</span></span><br><span class="line"><span class="comment">// ... todo</span></span><br><span class="line">err := registry.ShutdownService(address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Service is running in %v\n"</span>, address)</span><br><span class="line">fmt.Println(<span class="string">"Registry service started. Press any key to stop."</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">srv.Shutdown(ctx)</span><br><span class="line">err := registry.ShutdownService(address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>至此，可以开始专心的写业务了</p></blockquote><h3 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h3><p>得益于Go高并发的优势，开启数百万个的<code>goroutine</code>的开销也不会很大，非常的轻量！🛫<br>因此代码实现起来很轻松，大体思路和<strong>端口扫描器</strong>类似，在此基础上根据目标特征添加判断条件即可<br>端口扫描器代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">address := fmt.Sprintf(<span class="string">"192.168.2.122:%d"</span>, p)</span><br><span class="line">fmt.Printf(<span class="string">"start %s\n"</span>, address)</span><br><span class="line">conn, err := net.DialTimeout(<span class="string">"tcp"</span>, address, time.Second*<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">results &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">results &lt;- p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">30000</span>)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">scanEndPort := <span class="number">65535</span></span><br><span class="line"><span class="keyword">var</span> openPorts []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(ports, results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// push port to channel</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= scanEndPort; i++ &#123;</span><br><span class="line">ports &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ports)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= scanEndPort; i++ &#123;</span><br><span class="line">res := &lt;-results</span><br><span class="line"><span class="keyword">if</span> res != <span class="number">0</span> &#123;</span><br><span class="line">openPorts = <span class="built_in">append</span>(openPorts, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(results)</span><br><span class="line">sort.Ints(openPorts)</span><br><span class="line"><span class="keyword">for</span> _, port := <span class="keyword">range</span> openPorts &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d opend\n"</span>, port)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试器"><a href="#测试器" class="headerlink" title="测试器"></a>测试器</h3><p>测试器主要功能是从数据库中取出教务系统地址，然后测试。与扫描器不同仅在于扫描器是写，测试器是读。因此这部分内容和扫描器实际上是在同个包内的，只是逻辑上将它分离了出来。   </p><p>这部分其实和<code>consul</code>的功能是重复的，因此代码不过多赘述</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>由于校园网中，教务系统的地址不会太多，因此数据库的选择十分的随意(不存在性能方面的要求),所以这里使用自己熟悉的<code>redis</code>作为数据库。<br><strong>由于本系统是和官方的负载均衡并行的</strong> 因此存在某些结点用于两者共同访问导致压力上涨，响应不及时，因此利用<code>redis</code>的<code>sorted-set</code>在测试的时候，将响应快的地址设置高分数，使用<code>sorted-sets</code>的好处还有一个就是，集合的元素都是不重复的！，对于代理池来说，这个分数代表着教务系统地址稳定性的重要标准，因此设置分数的规则如下：</p><ul><li>基本分：10分，最高分：20</li><li>测试器设置一个更严格的超时时间来判断结点是否流畅</li><li>分数<strong>基本分</strong>为可用，检测器会定时循环检测每个代理可用情况，一旦检测到有可用的代理则立即置为<strong>最高分</strong></li><li>新获取的代理分数设置为<strong>基本分</strong>，如果测试可行(流畅)则置为满分，不可行(超时)则分数减一</li><li>分数减到0后代理移除</li></ul><p>由于是内网环境，分数与超时时间可以根据实际情况设置更严格</p><p>主要功能就是简单的CRUD啦，本文只讲逻辑与伪代码，实现部分就不多说了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set jwglxt to max score</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(addr discover.Addr)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">member, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZAdd(ctx, redisConfig.Key, &amp;redis.Z&#123;</span><br><span class="line">Score:  SCORE_MAX,</span><br><span class="line">Member: member,</span><br><span class="line">&#125;).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// decrease proxy score</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrease</span><span class="params">(addr discover.Addr)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">member, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZIncrBy(ctx, redisConfig.Key, <span class="number">-1</span>, <span class="keyword">string</span>(member)).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">score := rdb.ZScore(ctx, redisConfig.Key, <span class="keyword">string</span>(member))</span><br><span class="line"><span class="keyword">if</span> score.Val() &lt;= <span class="number">0.00</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"%v current score %v, remove.\n"</span>, addr, score.Val())</span><br><span class="line">err := rdb.ZRem(ctx, redisConfig.Key, member).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add new proxy to redis</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(addrs discover.Addrs)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">buf, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZAdd(ctx, redisConfig.Key, &amp;redis.Z&#123;</span><br><span class="line">Score:  SCORE_DEFAULT,</span><br><span class="line">Member: buf,</span><br><span class="line">&#125;).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="consul-upsync-nginx实现动态负载均衡"><a href="#consul-upsync-nginx实现动态负载均衡" class="headerlink" title="consul-upsync-nginx实现动态负载均衡"></a>consul-upsync-nginx实现动态负载均衡</h2><p>该部分可以说是系统实现的关键了，因为<code>nginx</code>自带的负载均衡是写死的，不能根据后端情况动态调整，通过一番搜索对比，最终决定了<code>consul</code> + <code>upsync</code>方案。   </p><ol><li><code>upsync</code> 一个Nginx的模块(扩展)</li><li><code>consul</code> 一个分布式高可用的系统</li></ol><p>这部分仅限于“能用”阶段，笔者也不太懂，就不乱说啦！<br>主要就是<strong>Api服务</strong>定时的获取数据库内容(分数作为权重)，然后推送到<strong>consul</strong>中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该项目是学习Go时的一个练手项目，很多地方都不太好，因此仓库就不开源了🐕</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上学期开始，学校的教务系统更新了。新版的正方多了一个负载均衡的功能，但无奈实在做的太差了！为什么这么说尼？&lt;br&gt;因为在上学期抢课的时候入口网关依旧拉闸，而真正的后端服务器访问速度比德芙还丝滑。因此暂将锅甩给负载均衡服务器。既然学校的负载均衡拉闸，那么就有了 &lt;strong&gt;“帮学校做负载均衡”&lt;/strong&gt; 的想法。&lt;br&gt;大体的思路就是，通过扫描内网网段发现隐藏的地址，然后负载均衡这些隐藏的地址。&lt;br&gt;既然是负载均衡，第一时间想到的就是&lt;code&gt;Nginx&lt;/code&gt;了，通过资料搜集，大致确定了基本的流程，因此有了这么的这个流程图:&lt;/p&gt;
&lt;img src=&quot;/2021/09/05/A-distributed-with-Go/floatChart.dio.png&quot; class=&quot;&quot; title=&quot;floatChart&quot;&gt;</summary>
    
    
    
    <category term="搞事情" scheme="https://blog.farmer233.top/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="爬虫" scheme="https://blog.farmer233.top/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="正方教务系统" scheme="https://blog.farmer233.top/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="nginx" scheme="https://blog.farmer233.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>新版正方教务系统登录实现</title>
    <link href="https://blog.farmer233.top/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.farmer233.top/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-03T04:38:19.000Z</published>
    <updated>2021-09-03T15:42:17.737Z</updated>
    
    <content type="html"><![CDATA[<p>最近开学后相信很多同学都发现课表小程序等无法使用了，这是因为学校更新了正方教务系统，导致了大批基于旧版正方系统的校园小程序无法继续爬取课表。</p><p>之前曾在GitHub上看到过本校师兄开发的<code>school-api</code>–一个基于旧版正方的python SDK，但新版无法使用。因此花了两天时间研究了下新版正方的登录(能登录后续的就EZ啦~) </p><p>既然都弄了，因此计划开发一个新的SDK。我比较懒 暂命名为<code>new-school-sdk</code>，项目目前还在开发中，先将登录的流程、验证码识别的思路罗列出来。(拿到了cookies 还有啥不能干嘛)</p><p>项目Github地址: <a href="https://github.com/Farmer-chong/new-school-sdk" target="_blank" rel="noopener">https://github.com/Farmer-chong/new-school-sdk</a> </p><h2 id="登录前期准备"><a href="#登录前期准备" class="headerlink" title="登录前期准备"></a>登录前期准备</h2><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/zf-index.png" class="" title="zf-index"><p>通过观察发现，有以下几个难点：</p><ol><li>新版正方使用Java进行开发且并非前后端分离，因此只要我们能拿到<code>cookie</code>即能完成登录。</li><li>验证码的识别</li><li>正方使用了Rsa对数据进行加密</li></ol><p>针对上述问题，开始一一解决</p><h2 id="验证码部分"><a href="#验证码部分" class="headerlink" title="验证码部分"></a>验证码部分</h2><p>前置工作准备好后，开始从服务器获取验证码并进行验证</p><h3 id="获取验证码"><a href="#获取验证码" class="headerlink" title="获取验证码"></a>获取验证码</h3><p>网络抓包发现，验证码是异步获取的，每次刷新都会发送一个请求到<code>/zfcaptchaLogin</code></p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/network-captcha.png" class="" title="captcha"><p>请求报文内容有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"type": "refresh"</span><br><span class="line">"rtk": "56f88546-d402-4afd-88b5-82a203258da8"</span><br><span class="line">"time": "1630645045207"</span><br><span class="line">"instanceId": "zfcaptchaLogin"</span><br></pre></td></tr></table></figure><p>响应报文内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">imtk: "29730cb5-d7ff-4fc9-aa9d-e3efc0a07f55"</span><br><span class="line">mi: "a8f191af-f267-4681-881a-54558298db09.png"</span><br><span class="line">msg: ""</span><br><span class="line">si: "1ccd27c6-6208-41f9-adfb-13beafa6d954.png"</span><br><span class="line">status: "success"</span><br><span class="line">t: 1630645937179</span><br><span class="line">vs: "not_verify"</span><br></pre></td></tr></table></figure><p>观察请求报文发现需要<code>type</code>、<code>rtk</code>、<code>time</code>和<code>instanceId</code>这几个字段。</p><p>其中<code>rtk</code>未知，因此开始寻找其出现的地方。通过查找发现rtk出现在一个js文件中，初步猜测<code>rtk</code>是一个令牌，由服务器随机生成的。<br>因此我们要先获取<code>rtk</code>令牌，然后利用正则表达式将其值提取出来。</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/network-find-rtk.png" class="" title="rtk"><h3 id="下载验证图片"><a href="#下载验证图片" class="headerlink" title="下载验证图片"></a>下载验证图片</h3><p>但现在仍然无法获取验证图片的原始数据，再观察<code>img</code>的<code>src</code>属性，得知响应报文中的<code>mi</code>和<code>si</code>分别别是<code>验证码</code>和<code>滑块</code>。并且需要的url参数我们也已经获取了。</p><p>向<code>/zfcaptchaLogin</code>发送一个<code>GET</code>请求，请求参数如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: image</span><br><span class="line">id: 上一步响应体中的si</span><br><span class="line">imtk: 上一步响应体中的imtk</span><br><span class="line">t: 时间戳</span><br><span class="line">instanceId: zfcaptchaLogin</span><br></pre></td></tr></table></figure><h3 id="滑动验证码识别"><a href="#滑动验证码识别" class="headerlink" title="滑动验证码识别"></a>滑动验证码识别</h3><p>上文中有提到，参考这篇文章: <a href="https://blog.dairoot.cn/2021/06/26/zf-sliding-captcha/" target="_blank" rel="noopener">https://blog.dairoot.cn/2021/06/26/zf-sliding-captcha/</a></p><p>大致流程如下：</p><ol><li>将图片灰度化</li><li>识别出一段颜色差小于阈值的线(竖的)</li><li>识别出来的这段线不能太短(要和缺口差不多高)</li></ol><p>因此即可计算出该线的x轴坐标，因此得到滑块偏移量。  </p><h3 id="模拟人手拖动-amp-发起验证请求"><a href="#模拟人手拖动-amp-发起验证请求" class="headerlink" title="模拟人手拖动&amp;发起验证请求"></a>模拟人手拖动&amp;发起验证请求</h3><p>从上一步中，我们得到了偏移量<code>X</code>和<code>Y</code>，接下来就要开始模拟人手拖动滑块的过程了。人手滑动验证码时，一般都是先快后慢的一个速度曲线，因此利用物理学公式分段设置加速度<code>a</code>，前半段<code>a &gt; 0</code>，后半段<code>a &lt; 0</code>。<br>当前速度用<code>v</code>表示，初速度用<code>v0</code>，位移用<code>x</code>，时间用<code>t</code>，它们之间满足如下关系：<br><code>x = v0 * t + 0.5 * a * t^2</code><br><code>v = v0 + a * t</code><br>移动算法的代码实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_track</span><span class="params">(self, distance, y)</span>:</span></span><br><span class="line">    <span class="string">"""模拟人手滑动</span></span><br><span class="line"><span class="string">    通过设置前快后慢的加速度，模拟人手滑动</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        distance ([int]): [移动距离]</span></span><br><span class="line"><span class="string">        y ([int]): [滑块Y值]</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        [list]: [坐标数组]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    start = <span class="number">1200</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    track = []</span><br><span class="line">    <span class="comment"># 减速阈值</span></span><br><span class="line">    mid = distance * <span class="number">4</span> / <span class="number">5</span></span><br><span class="line">    <span class="comment"># 计算间隔</span></span><br><span class="line">    t = <span class="number">0.2</span></span><br><span class="line">    <span class="comment"># 初速度</span></span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; distance:</span><br><span class="line">        <span class="comment"># 加速-&gt;加速度为 2; 减速-&gt;加速度为-3</span></span><br><span class="line">        a = <span class="number">2</span> <span class="keyword">if</span> current &lt; mid <span class="keyword">else</span> <span class="number">-3</span></span><br><span class="line">        v0 = v</span><br><span class="line">        <span class="comment"># 当前速度 v = v0 + at</span></span><br><span class="line">        v = v0 + a * t</span><br><span class="line">        <span class="comment"># 移动距离 x = v0t + 1/2 * a * t^2</span></span><br><span class="line">        move = v0 * t + <span class="number">1</span> / <span class="number">2</span> * a * t * t</span><br><span class="line">        <span class="comment"># 当前位移量</span></span><br><span class="line">        current += move</span><br><span class="line">        <span class="comment"># 加入轨迹</span></span><br><span class="line">        track.append(&#123;<span class="string">"x"</span>: start + int(current), <span class="string">"y"</span>: y, <span class="string">"t"</span>: int(time.time() * <span class="number">1000</span>)&#125;)</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> track</span><br></pre></td></tr></table></figure><p>至此，我们得到了发起请求的所有数据，因此向<code>/zfcaptchaLogin</code>发送一个<code>POST</code>请求，请求体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type: verify</span><br><span class="line">rtk: 56f88546-d402-4afd-88b5-82a203258da8</span><br><span class="line">time: 1630650071446</span><br><span class="line">mt: 将模拟滑动的内容通过base64编码</span><br><span class="line">instanceId: zfcaptchaLogin</span><br><span class="line">extend: 将UA进行编码</span><br></pre></td></tr></table></figure><p>当验证通过时，得到如下的响应体:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg: ""</span><br><span class="line">status: "success"</span><br><span class="line">vs: "verified"</span><br></pre></td></tr></table></figure><h2 id="登录部分"><a href="#登录部分" class="headerlink" title="登录部分"></a>登录部分</h2><h3 id="获取RSA公钥"><a href="#获取RSA公钥" class="headerlink" title="获取RSA公钥"></a>获取RSA公钥</h3><p>通过查看页面源码和点击登录后抓包，登录发送一个请求到<code>/xtgl/login_slogin.html</code>，然后返回一个302的跳转。<br>其中请求报文内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">csrftoken: csrftoken</span><br><span class="line">language: zh_CN</span><br><span class="line">yhm: 登录账号</span><br><span class="line">mm: 加密后的密码</span><br><span class="line">mm: 加密后的密码</span><br></pre></td></tr></table></figure><p>此处<code>csrftoken</code>和<code>mm</code>两个字段是未知的。其中<code>csrf</code>令牌是为了防止攻击的，一般包含在<code>form</code>表单中，由后端生成。因此我们可以直接从页面中提取。如下图：</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/csrftoken.png" class="" title="csrftoken"><p>而<code>mm</code>字段，通过对前端异步请求部分的代码进行分析后，发现是利用<code>RSA</code>进行加密，从抓包中可以发现一个发送到<code>/login_getPublicKey.html</code>地址的<code>GET</code>请求。其响应体内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exponent: "AQAB"</span><br><span class="line">modulus: "AIdzVtHXJLlh5vOlWFiRnWHc1xaChgqY1u4LNpaMjVUByVHwdvMMmlw4np8u/B3esIS2hsdQ7nRkrzWYYbkTWo8bm2LGS0H3/h1GVjLWaMrn1uj6lMYz0Y0O0AMUc19y23XRnSM7Q/d9V7tk6oS1HwyUKJwA7aSTgyenhNj26XrL"</span><br></pre></td></tr></table></figure><p>因此得到了<code>RSA</code>的<code>指数</code>和<code>模</code>，但这里的<code>modulus</code>长度为 172。大概率是正方修改过加密，在<code>JavaScript</code>文件的注释中也可以看到。<br>本来是打算自己重写一个python版的实现，后来在<code>GitHub</code>上发现已有前人栽树，我乘凉就好啦！ </p><blockquote><p>PyRsa仓库: <a href="https://github.com/hibiscustoyou/pyrsa" target="_blank" rel="noopener">https://github.com/hibiscustoyou/pyrsa</a></p></blockquote><p>到现在为止，整个登录流程的未知项就全解决了！🛫🍯</p><h3 id="开始登录"><a href="#开始登录" class="headerlink" title="开始登录"></a>开始登录</h3><p>再次观察数据包的流程，得知登录各项的顺序并做优化：</p><p><strong>! 注意，在登录发生302跳转的时候，cookie会发生改变 !</strong></p><ol><li>访问登录页面，获取<code>csrf</code>和原始的<code>cookies</code></li><li>获取<code>rsa</code>公钥</li><li>处理滑块验证</li><li>发起登录，得到登录后的<code>cookie</code></li></ol><p>成功截图：</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/login.png" class="" title="login"><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>sdk开发中，希望大佬们多多给意见或者一起开发哈！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开学后相信很多同学都发现课表小程序等无法使用了，这是因为学校更新了正方教务系统，导致了大批基于旧版正方系统的校园小程序无法继续爬取课表。&lt;/p&gt;
&lt;p&gt;之前曾在GitHub上看到过本校师兄开发的&lt;code&gt;school-api&lt;/code&gt;–一个基于旧版正方的pytho</summary>
      
    
    
    
    <category term="搞事情" scheme="https://blog.farmer233.top/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="爬虫" scheme="https://blog.farmer233.top/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="正方教务系统" scheme="https://blog.farmer233.top/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Golang基础语法笔记 | 数组、切片&amp;映射</title>
    <link href="https://blog.farmer233.top/2021/08/20/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.farmer233.top/2021/08/20/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-19T16:30:25.000Z</published>
    <updated>2021-08-29T17:59:56.159Z</updated>
    
    <content type="html"><![CDATA[<p>Go入门和《Go语言实战》的笔记，本篇总结了基础的数组、切片和哈希表的内容。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是切片和映射的基础数据结构，因此了解数组的工作原理有助于理解切片和映射。<br>和C语言一样，在go中数组也是一段<strong>连续</strong>、<strong>长度固定</strong>用于存储<strong>同一类型</strong>元素的连续块。</p><h3 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h3><p>数组的声明和初始化，和其他类型差不多。声明的原则是：</p><ol><li>指明存储数据的类型。</li><li>存储元素的数量，也就是数组长度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure></li></ol><p>声明变量时，总会使用对应类型的灵芝累对变量进行初始化，如上面的代码声明了一个数组<code>array</code>，但我们还没有对他进行初始化，此时这个数组内的值，就是对应类型的零值=&gt; 这里的对应类型时<code>int</code>，因此改数组目前为5个0 <code>[0,0,0,0,0]</code><br>由于数组初始化后长度是固定的，如果需要存储更多的元素则需要进行扩容。也就是需要再创建一个更长的数组，再把原来的数组复制到新数组里面。    </p><p>上面的数组仅仅只是<strong>声明</strong>，go还可以很方便的<strong>初始化并声明</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码相当于下面:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">array = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>除此之外，go语言还能自动计算声明数组的长度，也就是根据内容，自动分配长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>有的时候我们已知数组的长度，但内容只知道个别几个，我们可以用下面这种方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p>这样我们声明了一个长度为<code>5</code>的数组，并且初始化索引为<code>1</code>和<code>3</code>的元素</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组使用上和别的语言没有太大的差异，主要就是通过下标访问。值得关心的是，Go语言的指针数组十分的好用<br><strong>将一个指针数组赋值给另一个</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]*<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">arr2 := [<span class="number">3</span>]*<span class="keyword">string</span>&#123;<span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>)&#125;</span><br><span class="line"></span><br><span class="line">*arr2[<span class="number">0</span>] = <span class="string">"Red"</span></span><br><span class="line">*arr2[<span class="number">1</span>] = <span class="string">"Blue"</span></span><br><span class="line">*arr2[<span class="number">2</span>] = <span class="string">"Green"</span></span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">arr1 = arr2</span><br></pre></td></tr></table></figure><p>此时复制后的两个数组则指向同一组字符串了。</p><h3 id="函数间传递数组"><a href="#函数间传递数组" class="headerlink" title="函数间传递数组"></a>函数间传递数组</h3><p>在函数间传递变量时，总是以值的方式传递（也就是值传递）。因此在函数间传递数组是一个开销很大的操作–比如有个占用<code>8M</code>内存的数组，那么每次调用这个函数的时候go都会在栈上分配8MB的内存，试想一下同时调用100次这个函数，占用的内存会多么的惊人。<br>虽然Go自己会处理复制的这个操作，但还有一种更优雅的方法来处理这个操作，这个方法在C中十分的常见-&gt;<strong>传入指向数组的指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个8MB的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [le6]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">foo(&amp;arr)</span><br><span class="line"></span><br><span class="line">fun foo(arr *[le6]<span class="keyword">int</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是传递数组的指针的例子，会发现数组被修改了。所以这种情况虽然节省了复制的内存，但是要谨慎使用，因为一不小心，就会修改原数组，导致不必要的问题。</p><blockquote><p>这里注意，数组的指针和指针数组是两个概念，数组的指针是<code>*[5]int</code>,指针数组是<code>[5]*int</code>，注意<code>*</code>的位置。</p></blockquote><p>针对函数间传递数组的问题，比如复制问题，比如大小僵化问题，都有更好的解决办法，这个就是切片，它更灵活。</p><h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h2><p>切片是一种数组结构，它是围绕动态数组的概念构建的（⚠<strong>和python的切片不完全相同</strong>）。切片可以按需自动增长和缩小，因为切片底层内存也是在连续的块中分配的，所以切片还有索引、迭代以及垃圾回收等好处</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>切片的底层是数组，切片本身非常的小，它是对底层数组进行了抽象。切片有3个字段的数据结构，包含了Go需要操作数组的元数据。<br>这三个字段分别是<code>指向底层数组的指针</code>、<code>长度(切片能访问元素的个数)</code>和<code>切片总体的容量(真实容量)</code></p><blockquote><p>为了解决数组长度不可变，切片实际上就是提前声明了一个更长的数组(即切片的容量)，而切片的长度表示当前切片内能访问的元素的数量。</p></blockquote><p><strong>因此切片有这样一条公式：</strong><code>长度&lt;=容量</code></p><h3 id="声明-amp-初始化-amp-使用"><a href="#声明-amp-初始化-amp-使用" class="headerlink" title="声明&amp;初始化&amp;使用"></a>声明&amp;初始化&amp;使用</h3><p><strong>1. make和切片字面量</strong></p><p>使用<code>make</code>函数时，需要传入一个参数，指定切片的长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度和容量都是5的字符串切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>前面说到，切片的长度和容量是两个不一样的概念，因此创建的时候也可以指定<code>长度</code>和<code>容量</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为3，容量为5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>除了使用<code>make</code>函数，我们还可以使用切片<strong>字面量</strong>来声明切片–指定初始化的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>可以发现切片和创建数组非常像，只不过不用指定<code>[]</code>中的值。  <strong>注意</strong>此时切片的长度和容量是相等的，并且会根据我们指定额字面量推到出来，当然我们也可以只初始化某个索引的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 空切片和nil切片</strong><br>有的时候我们需要声明一个值为<code>nil</code>的切片(nil切片)。只要在声明式不做初始化就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>空切片和nil切片不同的地方在于，空切片的底层数组包含0个元素，也就是说没有分配任何存储空间。<br>但切片里面的<strong>指向底层数组的指针</strong>是有内容的，而nil切片<strong>指向底层数组的指针</strong>则为nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>3. 使用切片</strong><br>go的切片用法上和python的类似，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// newSlice -&gt; 2,3</span></span><br></pre></td></tr></table></figure><p>需要注意，第一个切片因为使用字面量的方式，因此它的长度和容量都为5。不过之后的<code>newSlice</code>就不一样了，对于<code>newSlice</code>来说其底层数组的容量只有4个元素，切片长度为2。根据下面的公式，可以计算任意切片的长度和容量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于底层数组容量为K的切片 slice[i:j] </span><br><span class="line">长度: j - i</span><br><span class="line">容量: k - i</span><br></pre></td></tr></table></figure><blockquote><p>由于切片是在元切片的基础上的抽象，因此新的切片和旧切片实际上指向的是同一个数组，故修改同一个索引的内容时会导致原切片的内容发生改变</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := array[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// array -&gt; 1,2,3,4,5</span></span><br><span class="line"><span class="comment">// newSlice -&gt; 2, 3</span></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">233</span></span><br><span class="line"><span class="comment">//  array -&gt; 1,2,233,4,5</span></span><br><span class="line"><span class="comment">//  newSlice -&gt; 2, 233</span></span><br></pre></td></tr></table></figure><p><strong>三个索引的切片</strong><br>创建切片时，第三个索引选项可以用来<strong>控制新切片的容量</strong>。⚠其目的并不是增加容量，而时限制容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source := []<span class="keyword">string</span>&#123;<span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Plum"</span>, <span class="string">"Banana"</span>, <span class="string">"Grape"</span>&#125;</span><br><span class="line"><span class="comment">// 数组: [2:3)  ; 容量: [2, 4)</span></span><br><span class="line"><span class="comment">// 因此长度: 1; 容量: 2</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>第三个选项也不可以超出索引范围!!!</strong></p><h3 id="切片增长"><a href="#切片增长" class="headerlink" title="切片增长"></a>切片增长</h3><p>按需增长可以说是切片的一个重要的特性。Go内置的<code>append</code>函数会处理增长长度时所有的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>因为<code>newSlice</code>在底层数组里还有额外的容量可用，append会将可用的元素合并到切片的长度，并对其进行赋值。由于和原始的<code>slice</code>共享同一个底层数组，slice中索引为3的元素的值也被改动了。<br>如果底层数组没有足够的可用容量，append会创建一个新的底层数组，将被引用的现有值复制到新数组里，再追加新的值。</p><blockquote><p>append会智能地处理底层数组地容量增长，当切片容量小于1000个元素时总会成倍地增加容量，超过1000后容量的增长因子设为1.25(增长算法不恒定)</p></blockquote><p>此外，通过<code>...</code>操作符，把一个切片追加到另一个切片里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, slice...)</span><br></pre></td></tr></table></figure><h3 id="迭代切片"><a href="#迭代切片" class="headerlink" title="迭代切片"></a>迭代切片</h3><p>切片是一个集合，我们就可以迭代其中的元素。与python类似，Go有个特殊的关键字<code>range</code>，它可以配合<code>for</code>来迭代切片里的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d, value:%d\n"</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中可以看到，迭代的时候会返回两个值: <code>index</code>和<code>value</code>，这里的<code>value</code>是一个副本。<br>需要强调的是，range创建了每个元素的<strong>副本</strong>，而不是直接返回该元素的引用。<br>很多时候，我们使用迭代都不需要索引<code>index</code>，此时可以使用占位符<code>_</code>来忽略这个值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">fmt.Printf(<span class="string">"value:%d\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>总是从头开始迭代。如果需要更多的控制，依旧可以使用传统的for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Index: %d Value: %d\n"</span>, index, slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line">Index: <span class="number">2</span> Value: <span class="number">3</span></span><br><span class="line">Index: <span class="number">3</span> Value: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>有两个特殊的内置函数<code>len</code>可以用于处理数组、切片和通道。对于切片来说，<code>len</code>返回切片的长度，<code>cap</code>返回切片的容量。</p><h3 id="函数间传递"><a href="#函数间传递" class="headerlink" title="函数间传递"></a>函数间传递</h3><p>在函数间传递切片的时候，就是要以值的方式传递切片，因为切片的尺寸很小，在函数间复制和传递切片成本也很低。（因为切片的数据结构只是一个指向数组的指针、长度和容量，不是把整个数组复制）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, le6)</span><br><span class="line">slice = foo(slice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射(Map)"></a>映射(Map)</h2><p>正如标题所示，在《Go语言实战》中Map翻译成映射，相比于翻译相信Map更广为人知。<br>Map是一种数据结构(哈希表 or 散列表)，用来存储一系列的<strong>键值对</strong>，如果你学习过别的语言相信看到这你就明白Map是什么了。在<code>python</code>中这样的数据结构称为<code>dict(字典)</code>、<code>JavaScript</code>中称为<code>json(JavaScript Object Notation)</code></p><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>Map是Go语言中哈希表的实现，因此我们每次迭代Map时打印的Key和Value时无序的，每次迭代都是不一样的。   </p><p>Map的散列表中包含一组桶，在存储、删除或查找键值对的时候，所有操作都要线选择一个桶，如何选择桶？就是先把要查找的<code>key</code>传给哈希函数，从而<strong>生成一个索引</strong>，进而找到对应的桶。</p><p>因此随着<em>映射</em>的增加，索引会分布的越来越均匀，因此访问键值对的速度就越快。（参考哈希表相关内容）由于本文主要是学习Go基础，因此不再继续深入，只要记住<strong>Map是无序的</strong></p><h3 id="声明-amp-初始化"><a href="#声明-amp-初始化" class="headerlink" title="声明&amp;初始化"></a>声明&amp;初始化</h3><p>Map的创建有如下几种方式：</p><ol><li><code>make</code>函数声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></li><li><code>map</code>字面量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何键值对-&gt;也就是一个空map</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 赋予内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>&#125;</span><br><span class="line"><span class="comment">// 多个内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>,<span class="string">"李四"</span>:<span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Map的键可以是任何值，键的类型可以是内置的类型，也可以是结构类型，但是不管怎么样，这个键可以使用<code>==</code>运算符进行比较，所以像切片、函数以及含有切片的结构类型就不能用于Map的键了，因为他们具有引用的语义，不可比较。</p><blockquote><p>总结: 对于Map的值来说没有什么限制，但切片这种类型在键里不能用的，可以用在值里</p></blockquote><h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><p>Go语言的Map和别的语言都大同小异，使用非常简单和数组切片差不多   </p><p>如果键张三存在，则对其值修改，如果不存在，则新增这个键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">dict[<span class="string">"张三"</span>] = <span class="number">43</span></span><br><span class="line">age := dict[<span class="string">"张三"</span>]</span><br></pre></td></tr></table></figure><p>很多时候我们都要判断Map中是否存在某个键值对.在Go Map中，如果我们获取一个不存在的键的值，也是可以的，返回的是<em>值类型</em>的零值，这样就会导致我们不知道是真的存在一个为零值的键值对呢，还是说这个键值对就不存在。对此，Map为我们提供了检测一个键值对是否存在的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age, exist := dict[<span class="string">"李四"</span>]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这个例子，和获取键的值没有太大区别，只是多了一个返回值。第一个返回值是键的值；第二个返回值标记这个键是否存在，这是一个boolean类型的变量，我们判断它就知道该键是否存在了。这也是Go多值返回的好处。</p><p>如果我们想删除一个键值对，可以使用内置的<code>delete</code>函数, <code>delete</code>函数接受两个参数，第一个是要操作的Map，第二个是要删除的Map的键。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(dict,<span class="string">"张三"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>delete函数删除不存在的键也是可以的，只是没有任何作用。</p></blockquote><p>在Go中，我们可以使用<code>range</code>迭代Map，这和遍历切片是一样的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>: <span class="number">43</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> dict &#123;</span><br><span class="line">fmt.Println(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rang</code>返回两个值，这和python是类似的，第一个是键，第二个是值。</p><h3 id="在函数间传递Map"><a href="#在函数间传递Map" class="headerlink" title="在函数间传递Map"></a>在函数间传递Map</h3><p>函数间传递Map是不会制造副本的，也就是说如果一个Map传递给一个函数，该函数对这个Map做了修改，那么这个Map的所有引用都会被修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"王五"</span>: <span class="number">60</span>, <span class="string">"张三"</span>: <span class="number">43</span>&#125;</span><br><span class="line">modify(dict)</span><br><span class="line">fmt.Println(dict[<span class="string">"张三"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(dict <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">dict[<span class="string">"张三"</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go入门和《Go语言实战》的笔记，本篇总结了基础的数组、切片和哈希表的内容。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;数组是切片和映射的基础数据结构，因此了解数组的工</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>提问中需要避免的一些行为</title>
    <link href="https://blog.farmer233.top/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/"/>
    <id>https://blog.farmer233.top/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/</id>
    <published>2021-08-06T18:10:23.000Z</published>
    <updated>2021-08-07T04:14:53.440Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/question.jpg" class="" title="img"><blockquote><p>本文灵感源于F大的这篇文章–<a href="https://frostming.com/2019/12-26/qa-no-action/" target="_blank" rel="noopener">社区问答中需要避免的行为</a>  </p></blockquote><p>长年混迹于QQ群、微信群和各大论坛，给人的印象和态度都属于是态度不友好类型。这并不是因为我鄙视菜鸟，我也曾是菜鸟（现在也是）。我这么做的原因也是我希望<strong>提问者能自己意识到问题所在</strong> -&gt; 为什么错了？应该怎么解决？这比我直接告诉他一个答案有帮助得多。逛社区这么久，我发现很多问题都提问的不是很好，不吐不快。<br>ps: 除了提问者应该学会提问外，回答者也有不好的回答。</p><h2 id="How-To-Ask-Questions"><a href="#How-To-Ask-Questions" class="headerlink" title="How To Ask Questions"></a>How To Ask Questions</h2><p>这个问题已经是听得耳朵起茧了，故不再赘述。但必须强调的是问问题是一门高深的学问，问的好不好直接影响到你是否能得到高效、直接、有效的回答。<br><strong>关于提问总结出有一下两个比较主要的问题：</strong></p><ol><li>不会提问</li><li>X-Y问题</li></ol><p>如果不会提问，<strong>一定要阅读下面的链接</strong>：</p><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md" target="_blank" rel="noopener">提问的智慧</a></li><li><a href="https://coolshell.cn/articles/10804.html" target="_blank" rel="noopener">X-Y问题</a></li></ul><h3 id="X-Y问题"><a href="#X-Y问题" class="headerlink" title="X-Y问题"></a>X-Y问题</h3><p>相比于不会提问，更让人恼火的是<code>X-Y问题</code>。概况起来如下：</p><ol><li>提问者想解决问题X</li><li>然后觉得Y可能是解决X问题的方法</li><li>但他不知道Y应该怎么做</li><li>于是他去问别人Y应该怎么做</li></ol><p>于是很多人都会热心的告诉这个人Y应该怎么处理，但大家都觉得Y这个方案比较怪异。经过大量的讨论浪费了大量的实践后人们终于明白了原始问题X，于是发现Y根本就不是用来解决X最合适的方案。<br>这个问题最大的问题在于：<strong>在一个根本错误的方向上浪费他人大量的时间和精力！！！</strong>十分的让人高血压！<br>关于X-Y问题，有许多的变种。不能说他们没有自己尝试动手解决问题，但这样的问题往往更浪费时间。</p><h2 id="用XXX干嘛，为什么不用XXX"><a href="#用XXX干嘛，为什么不用XXX" class="headerlink" title="用XXX干嘛，为什么不用XXX"></a>用XXX干嘛，为什么不用XXX</h2><blockquote><p>Q: 用Flask怎么做XXX？<br>A: 用Django吧</p></blockquote><p>某小白终于鼓起勇气，开始学某一框架，碰到了瓶颈，结果上来一提问，被安利了另一个框架，好嘛，白学了。这也很不负责任，我觉得要说服人用一个新的框架，接触新的知识，你得对两者都有相当的熟悉度，并且清楚两者的优劣。<br>如果你只是对其中一个比较熟悉，除非你确信已有方案确实做不到，或者要付出极大的代价才能实现，否则我会尽量沿用提问者已选择的方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/question.</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    <category term="吐槽" scheme="https://blog.farmer233.top/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集的最后一天</title>
    <link href="https://blog.farmer233.top/2021/08/02/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"/>
    <id>https://blog.farmer233.top/2021/08/02/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</id>
    <published>2021-08-02T10:48:19.000Z</published>
    <updated>2021-09-26T07:14:55.584Z</updated>
    
    <content type="html"><![CDATA[<p>终于刷完了，芜湖！🛫🛫🛫<br>这套题目集总体难度不高，适合刚学的时候作为随堂练习。<br>题目代码我也同步到<code>GitHub</code>仓库了🎈：<a href="https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1" target="_blank" rel="noopener">https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1</a></p><a id="more"></a><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例 1:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 输入为: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>因为是一颗二叉搜索树，因此每个节点都满足左边小、右边大这个特性。<br>因此每次判断的时候记录<strong>最小值</strong>和<strong>最大值</strong>，然后判断即可。解题思路如下：</p><ol><li>由题目得知是整型，因此最大最小值分别为最小、最大的整型数值</li><li>当前节点值和最大最小值比较，错误则返回<code>F</code></li><li>将当前节点的值作为最大、最小值传入左右子树</li><li>返回左右子树的判断结果</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> validBST(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validBST</span><span class="params">(root *TreeNode, min, max <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt;= min || root.Val &gt;= max &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> validBST(root.Left, min, root.Val) &amp;&amp; validBST(root.Right, root.Val, max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两数之和-IV-输入-BST"><a href="#两数之和-IV-输入-BST" class="headerlink" title="两数之和 IV - 输入 BST"></a>两数之和 IV - 输入 BST</h2><blockquote><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>], k = <span class="number">9</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>], k = <span class="number">28</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">4</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">1</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>提示:</p><ul><li>二叉树的节点个数的范围是  <code>[1, 104]</code>.</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>root</code> 为二叉搜索树</li><li><code>-105 &lt;= k &lt;= 105</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题的解题思路大致和<code>求两数和</code>差不多，只是将for循环换成了递归遍历，然后利用<code>hashMap</code>存储已遍历的内容。    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTarget</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">100</span>*<span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> preOrder(root, hashMap, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOrder</span><span class="params">(root *TreeNode, hashMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := hashMap[k-root.Val]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">hashMap[root.Val] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> preOrder(root.Left, hashMap, k) || preOrder(root.Right, hashMap, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><blockquote><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li><code>p、q</code> 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>解题思路：</p><ol><li>当前节点和<code>p、q</code>节点进行比较</li><li>如果是<code>p、q</code>节点、则返回该节点</li><li>获取左右子树的节点，当左右节点都存在，则证明当前节点为最近的<code>祖先节点</code></li><li>如果只有单一一个节点，则继续将该节点返回</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root == p || root == q &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> leftNode, rightNode *TreeNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.Val &gt; q.Val &#123;</span><br><span class="line"><span class="comment">// 左 大于 右 则交换。保证左边小于右边（p &lt; q)</span></span><br><span class="line">p, q = q, p</span><br><span class="line">&#125;</span><br><span class="line">leftNode = lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">rightNode = lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &amp;&amp; rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> leftNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rightNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于刷完了，芜湖！🛫🛫🛫&lt;br&gt;这套题目集总体难度不高，适合刚学的时候作为随堂练习。&lt;br&gt;题目代码我也同步到&lt;code&gt;GitHub&lt;/code&gt;仓库了🎈：&lt;a href=&quot;https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]二叉搜索树中的搜索&amp;插入</title>
    <link href="https://blog.farmer233.top/2021/08/02/Leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E6%8F%92%E5%85%A5/"/>
    <id>https://blog.farmer233.top/2021/08/02/Leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E6%8F%92%E5%85%A5/</id>
    <published>2021-08-02T10:35:07.000Z</published>
    <updated>2021-08-02T12:51:34.298Z</updated>
    
    <content type="html"><![CDATA[<p>第十三天了！快刷完了~！😊🛫<br>题目开始涉及二叉树、二叉堆等难一点的操作了，还有二叉树的调整。<br>做完感觉知识点掌握的更扎实了，果然温故而知新啊！</p><a id="more"></a><h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><blockquote><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p></blockquote><p>例如，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        <span class="number">4</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">2</span>   <span class="number">7</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">和值: <span class="number">2</span></span><br><span class="line">你应该返回如下子树:</span><br><span class="line"></span><br><span class="line">      <span class="number">2</span>     </span><br><span class="line">     / \   </span><br><span class="line">    <span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是<code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>.</p><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>因为这是一颗搜索树，因此搜索功能实现起来特别简单，思路如下：</p><ol><li>判断当前节点的值，相同则返回</li><li>判断当前节点的值与目标的值，根据大小选择左子树还是右子树</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root.Val == val &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Left, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Right, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p></blockquote><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>], val = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt=""></p><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">40</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>], val = <span class="number">25</span></span><br><span class="line">输出：[<span class="number">40</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>], val = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li><li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题感觉有点漏洞，因为这题是往一颗<strong>搜索二叉树</strong>里面插入<strong>一个</strong>数据，因此不会造成二叉树层数超标。<br>故思路如下：</p><ol><li>用搜索的思路，查找出插入位置</li><li>往目标位置插入</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;Val: val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第十三天了！快刷完了~！😊🛫&lt;br&gt;题目开始涉及二叉树、二叉堆等难一点的操作了，还有二叉树的调整。&lt;br&gt;做完感觉知识点掌握的更扎实了，果然温故而知新啊！&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]翻转二叉树&amp;路径总和</title>
    <link href="https://blog.farmer233.top/2021/08/01/Leetcode-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>https://blog.farmer233.top/2021/08/01/Leetcode-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2021-08-01T13:42:03.000Z</published>
    <updated>2021-08-02T10:37:27.418Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote><p>翻转一棵二叉树。</p></blockquote><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>利用递归，将左子树和右子树交换。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">left := invertTree(root.Right)</span><br><span class="line">root.Right = invertTree(root.Left)</span><br><span class="line">root.Left = left</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。<br>叶子节点 是指没有子节点的节点。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000</code> &lt;= Node.val &lt;= <code>1000</code></li><li><code>-1000</code> &lt;= targetSum &lt;= <code>1000</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题和之前的<code>求两数和</code>差不多思路，将已遍历的节点值放入<code>haspMap</code>中，并且每次访问节点的时候，计算当前节点和目标数相减后的值是否存在<code>hashMap</code>中。<br><strong>具体思路如下</strong></p><ol><li>读取当前节点的值</li><li>将<code>当前节点的值</code>放入<code>hashMap</code>中</li><li>判断 <code>targetSum - 当前节点的值</code> 是否在<code>hashMap</code>中</li><li>在则返回<code>true</code>,不在则继续遍历</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> targetSum == root.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;翻转二叉树&quot;&gt;&lt;a href=&quot;#翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;翻转二叉树&quot;&gt;&lt;/a&gt;翻转二叉树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;翻转一棵二叉树。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]第十一天-树的更多操作</title>
    <link href="https://blog.farmer233.top/2021/08/01/Leetcode-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%A0%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.farmer233.top/2021/08/01/Leetcode-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%A0%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/</id>
    <published>2021-08-01T13:21:23.000Z</published>
    <updated>2021-08-01T13:52:14.928Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="二叉树的层序遍"><a href="#二叉树的层序遍" class="headerlink" title="二叉树的层序遍"></a>二叉树的层序遍</h2><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line">q := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">p := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">node := q[j]</span><br><span class="line">ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q = p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue []*TreeNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Add</span><span class="params">(data *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Remove</span><span class="params">()</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">node := (*q)[<span class="number">0</span>]</span><br><span class="line">*q = (*q)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*q) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p></blockquote><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>简单的通过递归，在返回的时候判断左子树深还是右子树深，然后返回比较深的那颗子树的值。<br>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">leftDeep := maxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">rightDeep := maxDepth(root.Right) + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> leftDeep &gt;= rightDeep &#123;</span><br><span class="line"><span class="keyword">return</span> leftDeep</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rightDeep</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>和判断深度差不多，也是分为左子树和右子树。通过交叉传入左右子树判断节点的值是否相等。<br>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(p, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;二叉树的层序遍&quot;&gt;&lt;a href=&quot;#二叉树的层序遍&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层序遍&quot;&gt;&lt;/a&gt;二叉树的层序遍&lt;/h2&gt;&lt;h3 id=&quot;解题思路-amp-题解&quot;&gt;&lt;a href=&quot;#解题思</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]题目集第十天-树的开始</title>
    <link href="https://blog.farmer233.top/2021/07/31/Leetcode-%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%8D%81%E5%A4%A9-%E6%A0%91%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://blog.farmer233.top/2021/07/31/Leetcode-%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%8D%81%E5%A4%A9-%E6%A0%91%E7%9A%84%E5%BC%80%E5%A7%8B/</id>
    <published>2021-07-31T13:15:34.000Z</published>
    <updated>2021-08-01T13:29:24.129Z</updated>
    
    <content type="html"><![CDATA[<p>树是一种重要的数据结构，终于开始刷树了😊<br>今天刷的是二叉树的三种基本变量–二叉树的前序遍历、二叉树的中序遍历和二叉树的后序遍历。三种遍历大同小异，只是输出元素的位置不一样，就不过多赘述了。</p><h2 id="三种遍历"><a href="#三种遍历" class="headerlink" title="三种遍历"></a>三种遍历</h2><p>代码和leetcode上的不太一样，但稍微改动一下就能提交了。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeType <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">value       nodeType</span><br><span class="line">left, right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryTree proOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">preOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line">t.left.preOrder()</span><br><span class="line">t.right.preOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// binaryTree inOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">inOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t.left.inOrder()</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line">t.right.inOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryTree postOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t.left.postOrder()</span><br><span class="line">t.right.postOrder()</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTree</span><span class="params">(inputList *[]nodeType)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*inputList) == <span class="number">0</span> || inputList == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data := (*inputList)[<span class="number">0</span>]</span><br><span class="line">*inputList = (*inputList)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := &amp;TreeNode&#123;data, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">node.left = newTree(inputList)</span><br><span class="line">node.right = newTree(inputList)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputList := []nodeType&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">10</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">8</span>, <span class="literal">nil</span>, <span class="number">4</span>&#125;</span><br><span class="line">root := newTree(&amp;inputList)</span><br><span class="line">fmt.Println(<span class="string">"res"</span>, root.left.right.value)</span><br><span class="line">fmt.Println(<span class="string">"前序遍历"</span>)</span><br><span class="line">root.preOrder()</span><br><span class="line">fmt.Println(<span class="string">"中序遍历"</span>)</span><br><span class="line">root.inOrder()</span><br><span class="line">fmt.Println(<span class="string">"后续遍历"</span>)</span><br><span class="line">root.postOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;树是一种重要的数据结构，终于开始刷树了😊&lt;br&gt;今天刷的是二叉树的三种基本变量–二叉树的前序遍历、二叉树的中序遍历和二叉树的后序遍历。三种遍历大同小异，只是输出元素的位置不一样，就不过多赘述了。&lt;/p&gt;
&lt;h2 id=&quot;三种遍历&quot;&gt;&lt;a href=&quot;#三种遍历&quot; clas</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]有效的括号&amp;用栈实现队列</title>
    <link href="https://blog.farmer233.top/2021/07/31/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://blog.farmer233.top/2021/07/31/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2021-07-30T17:11:02.000Z</published>
    <updated>2021-07-31T13:16:13.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p></blockquote><p><strong>有效字符串需满足：</strong></p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"(]"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"([)]"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这道题和课堂例题没啥区别没啥好讲的，直接上代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">pars := []<span class="keyword">rune</span>&#123;</span><br><span class="line"><span class="string">'('</span>: <span class="string">')'</span>,</span><br><span class="line"><span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line"><span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">&#125;</span><br><span class="line">stack := []<span class="keyword">rune</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, c)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">jugeCh := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> c != pars[jugeCh] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><blockquote><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p></blockquote><p>实现 <code>MyQueue</code> 类：</p><ul><li>void push(int x) 将元素 x 推到队列的末尾</li><li>int pop() 从队列的开头移除并返回元素</li><li>int peek() 返回队列开头的元素</li><li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li></ul><p><strong>说明：</strong><br>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p><strong>进阶：</strong><br>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MyQueue"</span>, <span class="string">"push"</span>, <span class="string">"push"</span>, <span class="string">"peek"</span>, <span class="string">"pop"</span>, <span class="string">"empty"</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="keyword">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">myQueue.<span class="keyword">push</span>(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.<span class="keyword">push</span>(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.<span class="keyword">pop</span>(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这里利用了两个栈，一个栈处理输入另一个处理输出（in和out）。<br>利用栈的特性，当<strong>输出栈</strong>为空时将<strong>输入栈</strong>的内容<code>pop</code>到<strong>输出栈</strong>, 这样<strong>输出</strong>栈的顺序就是队列的顺序了！<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">in, out []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">this.in = <span class="built_in">append</span>(this.in, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">in2out</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(this.in) &gt; <span class="number">0</span> &#123;</span><br><span class="line">this.out = <span class="built_in">append</span>(this.out, this.in[<span class="built_in">len</span>(this.in)<span class="number">-1</span>])</span><br><span class="line">this.in = this.in[:<span class="built_in">len</span>(this.in)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.out) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将输入栈 弹出到输出栈中</span></span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line">out := this.out[<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line">this.out = this.out[:<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.out) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将输入栈 弹出到输出栈中</span></span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.out[<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(this.in) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.out) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;#有效的括号&quot; class=&quot;headerlink&quot; title=&quot;有效的括号&quot;&gt;&lt;/a&gt;有效的括号&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]反转链表&amp;删除排序链表中的重复元素</title>
    <link href="https://blog.farmer233.top/2021/07/23/Leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.farmer233.top/2021/07/23/Leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-22T16:30:03.000Z</published>
    <updated>2021-07-29T17:01:46.716Z</updated>
    
    <content type="html"><![CDATA[<p>第八天题目，涉及的都是些基本的链表操作~不算太难😀<br>去旅游玩几天👻🕊🕊🕊</p><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题第一时间想到了递归，当操作流程在<strong>递归</strong>触底前则表示正向递归，触底后计算则表示反向递归。<br>这里利用了<strong>反向递归</strong>（触底后操作），得到一个链表尾开头的链表和当前节点，然后将这条链添加当前元素。<br>此时，node节点表示反转后的链表。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">node := reverseList(head.Next)</span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><blockquote><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>返回同样按升序排列的结果链表。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题有个大前提<code>按升序排列的链表</code>, 这个链表是排好序的。通过判断当前节点和下一个节点的值是否想等，相等就删除下一个节点。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">node := head</span><br><span class="line"><span class="keyword">for</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node.Val == node.Next.Val &#123;</span><br><span class="line">node.Next = node.Next.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第八天题目，涉及的都是些基本的链表操作~不算太难😀&lt;br&gt;去旅游玩几天👻🕊🕊🕊&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集第七天-链表</title>
    <link href="https://blog.farmer233.top/2021/07/22/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E4%B8%83%E5%A4%A9-%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.farmer233.top/2021/07/22/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E4%B8%83%E5%A4%A9-%E9%93%BE%E8%A1%A8/</id>
    <published>2021-07-21T17:04:04.000Z</published>
    <updated>2021-07-22T16:30:27.652Z</updated>
    
    <content type="html"><![CDATA[<p>这次题目有三题，分别是<code>环形链表</code>、<code>合并两个有序链表</code>和<code>移除链表元素</code>.<br>其中<code>环形链表</code>比较值得一看，解法有三种，感觉第一种有点骚✨</p><a id="more"></a><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><blockquote><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递，</strong>仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p></blockquote><p><strong>进阶：</strong><br>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 [0, 104]</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题有好几个方法解决，如下：</p><ol><li>利用一个特殊的值覆盖已遍历的元素，当再次遇到该值时表示有回环</li><li>利用哈希表存储记录节点地址</li><li>快慢指针法（传统法） </li></ol><h4 id="特殊值法"><a href="#特殊值法" class="headerlink" title="特殊值法"></a>特殊值法</h4><p>这个方法感觉有点奇葩，特殊值要测试点中不存在才可以😄</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Val == <span class="number">114514</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.Val = <span class="number">114514</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希表存储节点"><a href="#哈希表存储节点" class="headerlink" title="哈希表存储节点"></a>哈希表存储节点</h4><p>这个方法只需要将链表遍历一次，但需要耗费更大的内存空间。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">nodeMap := <span class="keyword">map</span>[ListNode]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">node := head</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">nodeMap[*node]++</span><br><span class="line"><span class="keyword">if</span> nodeMap[*node] &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><p>这个是传统的方法，但有可能需要遍历几次闭环，等慢指针追上快指针。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p><strong>需要注意</strong>这题有一个大前提，题目给的两个链表都是<strong>升序</strong>的，因此这题类似前面的<code>合并两个有序数组</code>有点类似。</p><ol><li>通过比较头节点，小的添加到新链</li><li>遍历完其中一条链后，将另一条链直接拼接在后面<br>代码如下：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">res := &amp;ListNode&#123;&#125;</span><br><span class="line">node := res</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Next = l2</span><br><span class="line"><span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Next = l1</span><br><span class="line"><span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br><span class="line">tmp := &amp;ListNode&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">tmp.Val = l1.Val</span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp.Val = l2.Val</span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">node.Next = tmp</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], val = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], val = <span class="number">7</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题就是基本的删除链表元素，直接上代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">root := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">node := root</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Next != <span class="literal">nil</span> &amp;&amp; node.Next.Val == val &#123;</span><br><span class="line">node.Next = node.Next.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次题目有三题，分别是&lt;code&gt;环形链表&lt;/code&gt;、&lt;code&gt;合并两个有序链表&lt;/code&gt;和&lt;code&gt;移除链表元素&lt;/code&gt;.&lt;br&gt;其中&lt;code&gt;环形链表&lt;/code&gt;比较值得一看，解法有三种，感觉第一种有点骚✨&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集第六天</title>
    <link href="https://blog.farmer233.top/2021/07/21/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>https://blog.farmer233.top/2021/07/21/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%85%AD%E5%A4%A9/</id>
    <published>2021-07-21T15:56:16.000Z</published>
    <updated>2021-07-21T16:57:44.546Z</updated>
    
    <content type="html"><![CDATA[<p>这次题目有三题，分别是<code>字符串中的第一个唯一字符</code>、<code>赎金信</code>和<code>有效的字母异位词</code>.<br>今天三道题目的思路都差不多，感觉都是<code>两个数组的交集 II</code>的变形,内容篇幅可能比较长，目录可以快速定位到对应题目的解题思路&amp;题解.  </p><h2 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a>字符串中的第一个唯一字符</h2><blockquote><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p></blockquote><p>示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">s</span> = <span class="string">"leetcode"</span></span><br><span class="line">返回 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">s</span> = <span class="string">"loveleetcode"</span></span><br><span class="line">返回 <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>拿到题目的第一反应是和之前<code>两个数组的交集 II</code>一样的思路。<br>通过哈希表记录元素出现的下标，然后扫码字符串找出出现的次数为1的元素，然后返回该元素的下标。<br>大致思路: </p><ol><li>数组0-25表示’a’ -&gt; ‘z’</li><li>哈希表使用一个26长度的数组表示</li><li>数组内容表示元素出现次数</li></ol><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">items := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">items[s[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> items[s[i]-<span class="string">'a'</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><blockquote><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p></blockquote><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"a"</span>, <span class="attr">magazine</span> = <span class="string">"b"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"aa"</span>, <span class="attr">magazine</span> = <span class="string">"ab"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"aa"</span>, <span class="attr">magazine</span> = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题与上一题差不多，思路上甚至更像<code>两个数组的交集 II</code>，也是通过一个数组哈希表存储字符出现的次数。<br>第二次遍历的时候将数组内容减一，当内容为0时表示内容不够则返回<code>false</code></p><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">conMap := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(magazine); i++ &#123;</span><br><span class="line">conMap[magazine[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ransomNote); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> conMap[ransomNote[i]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">conMap[ransomNote[i]-<span class="string">'a'</span>]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br><strong>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</strong></p></blockquote><p>示例 1:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"anagram"</span>, <span class="attr">t</span> = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"rat"</span>, <span class="attr">t</span> = <span class="string">"car"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题应该就是<code>两个数组的交集 II</code>的变形了，今天这三题整体上思路都没啥区别，不过多赘述了。    </p><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">res := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">res[s[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> res[t[i]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">res[t[i]-<span class="string">'a'</span>]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line"><span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次题目有三题，分别是&lt;code&gt;字符串中的第一个唯一字符&lt;/code&gt;、&lt;code&gt;赎金信&lt;/code&gt;和&lt;code&gt;有效的字母异位词&lt;/code&gt;.&lt;br&gt;今天三道题目的思路都差不多，感觉都是&lt;code&gt;两个数组的交集 II&lt;/code&gt;的变形,内容篇幅可能比较长，目录</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]有效的数独&amp;矩阵置零</title>
    <link href="https://blog.farmer233.top/2021/07/20/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>https://blog.farmer233.top/2021/07/20/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</id>
    <published>2021-07-20T14:34:22.000Z</published>
    <updated>2021-07-20T14:53:58.707Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集第五天，<code>有效的数独</code>和<code>矩阵置零</code>.<br>其中<code>矩阵置零</code>比较有趣放在前面，<code>有效的数独</code>只是代码量比较长，逻辑部分并不难。  </p><a id="more"></a><h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h2><blockquote><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用<code>原地</code>算法。</p></blockquote><p>进阶：</p><ul><li>一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。<br>你能想出一个仅使用常量空间的解决方案吗？</li></ul><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[0].length</li><li>1 &lt;= m, n &lt;= 200</li><li>-231 &lt;= matrix[i][j] &lt;= 231 - 1</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p><strong>通过观察发现置零是将<code>0</code>的行号和列号记录下来，然后将记录下来的行列置零即可</strong><br>具体思路如下：</p><ul><li>当同一行有一个0时，则该行后面遇到0值时也无需关系这一行的变化-&gt;因为一行里面有一个0，整行都是0（列同理）</li><li>在同一行有两个0时需要注意，这意味着有两列也需要置零。</li></ul><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">row, col := []<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="built_in">len</span>(matrix); r++ &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="built_in">len</span>(matrix[r]); c++ &#123;</span><br><span class="line"><span class="keyword">if</span> matrix[r][c] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 记录</span></span><br><span class="line">row = <span class="built_in">append</span>(row, r)</span><br><span class="line">col = <span class="built_in">append</span>(col, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> row &#123;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> matrix[item] &#123;</span><br><span class="line">matrix[item][index] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> col &#123;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">value[item] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h2><blockquote><p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p></blockquote><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li></ul><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt=""></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。 但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>board.length == 9</li><li>board[i].length == 9</li><li>board[i][j] 是一位数字或者 ‘.’</li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>题目<del>没什么难度</del>，唯一需要注意的是：判断子矩阵的时候，是根据<code>当前坐标/矩阵大小</code>来决定的。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">rowBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line">colBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line">boxBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row:=<span class="number">0</span>; row&lt;<span class="number">9</span>; row++ &#123;</span><br><span class="line"><span class="keyword">for</span> col:=<span class="number">0</span>; col&lt;<span class="number">9</span>; col++ &#123;</span><br><span class="line"><span class="keyword">if</span> board[row][col] == <span class="string">'.'</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val := board[row][col] - <span class="string">'1'</span></span><br><span class="line"><span class="keyword">if</span> rowBuf[row][val] || colBuf[col][val] || boxBuf[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][val] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rowBuf[row][val] = <span class="literal">true</span></span><br><span class="line">colBuf[col][val] = <span class="literal">true</span></span><br><span class="line">boxBuf[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][val] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> digit &gt;= <span class="string">'1'</span> &amp;&amp; digit &lt;= <span class="string">'9'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRow</span><span class="params">(rows []<span class="keyword">byte</span>, col <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">9</span>; c++ &#123;</span><br><span class="line"><span class="keyword">if</span> rows[c] == digit &amp;&amp; c != col &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inColumn</span><span class="params">(g [][]<span class="keyword">byte</span>, column, row <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">9</span>; r++ &#123;</span><br><span class="line"><span class="keyword">if</span> g[r][column] == digit &amp;&amp; r != row &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRegion</span><span class="params">(g [][]<span class="keyword">byte</span>, row, column <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">startRow, startColumn := row/<span class="number">3</span>*<span class="number">3</span>, column/<span class="number">3</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> r := startRow; r &lt; startRow+<span class="number">3</span>; r++ &#123;</span><br><span class="line"><span class="keyword">for</span> c := startColumn; c &lt; startColumn+<span class="number">3</span>; c++ &#123;</span><br><span class="line"><span class="keyword">if</span> g[r][c] == digit &amp;&amp; r != row &amp;&amp; c != column &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集第五天，&lt;code&gt;有效的数独&lt;/code&gt;和&lt;code&gt;矩阵置零&lt;/code&gt;.&lt;br&gt;其中&lt;code&gt;矩阵置零&lt;/code&gt;比较有趣放在前面，&lt;code&gt;有效的数独&lt;/code&gt;只是代码量比较长，逻辑部分并不难。  &lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]重塑矩阵&amp;杨辉三角</title>
    <link href="https://blog.farmer233.top/2021/07/19/Leetcode-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>https://blog.farmer233.top/2021/07/19/Leetcode-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</id>
    <published>2021-07-19T11:49:09.000Z</published>
    <updated>2021-07-19T16:21:37.606Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集第四天，<code>重塑矩阵</code>和<code>杨辉三角</code>.</p><h2 id="重塑矩阵"><a href="#重塑矩阵" class="headerlink" title="重塑矩阵"></a>重塑矩阵</h2><blockquote><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。<br>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。<br>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。<br>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p></blockquote><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">1</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。新的矩阵是 <span class="number">1</span> * <span class="number">4</span> 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">2</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 <span class="number">2</span> * <span class="number">2</span> 矩阵转化为 <span class="number">2</span> * <span class="number">4</span> 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定矩阵的宽和高范围在 [<span class="number">1</span>, <span class="number">100</span>]。</span><br><span class="line">给定的 r 和 c 都是正数。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>解题思路大体就是先转成一维矩阵，然后再转成目标矩阵。核心思想是下面的公式:</p><ol><li>(i, j) -&gt; i * n + j =&gt; x</li><li>i=x / n</li><li>j=x % n</li></ol><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixReshape</span><span class="params">(mat [][]<span class="keyword">int</span>, r <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> m*n != r*c &#123;</span><br><span class="line"><span class="keyword">return</span> mat</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="built_in">make</span>([][]<span class="keyword">int</span>, r)</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> res &#123;</span><br><span class="line">res[r] = <span class="built_in">make</span>([]<span class="keyword">int</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m*n; i++ &#123;</span><br><span class="line">res[i/c][i%c] = mat[i/n][i%n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><blockquote><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></blockquote><p>示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>杨辉三角这算是一道经典题目了，大一就开始接触。这里主要用到这个特性-&gt;<code>每行长度等于当前列数 -&gt; 第一行只有一个，第二行有两个，第三行有三个。</code></p><p>代码如下: </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(numRows <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numRows; i++ &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> || j == i &#123;</span><br><span class="line">temp[j] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集第四天，&lt;code&gt;重塑矩阵&lt;/code&gt;和&lt;code&gt;杨辉三角&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;重塑矩阵&quot;&gt;&lt;a href=&quot;#重塑矩阵&quot; class=&quot;headerlink&quot; title=&quot;重塑矩阵&quot;&gt;&lt;/a&gt;重塑矩阵&lt;/h2&gt;&lt;b</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
  </entry>
  
</feed>
